<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人间失格</title>
  
  <subtitle>人间失格の博客</subtitle>
  <link href="https://heekaai.github.io/atom.xml" rel="self"/>
  
  <link href="https://heekaai.github.io/"/>
  <updated>2022-03-27T10:36:53.038Z</updated>
  <id>https://heekaai.github.io/</id>
  
  <author>
    <name>HeeKaai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图--最短路径问题</title>
    <link href="https://heekaai.github.io/posts/6.html"/>
    <id>https://heekaai.github.io/posts/6.html</id>
    <published>2022-03-22T02:26:19.000Z</published>
    <updated>2022-03-27T10:36:53.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>Dijkstra算法可以读作迪杰斯特拉算法。</p><p>Dijkstra算法用来解决<strong>单源最短路问题</strong>（划重点），也即：给定图和一个起点（源点），求解从源点到达其它顶点的最短路径。</p><p>具体实现：</p><p>（1）用一个bool型的数组来区分表示某个顶点是否已经访问过了，用一个数组记录源点到各顶点的最短距离并初始化（为INF），然后执行（2）-（3）步骤n次（一共n个顶点）。</p><p>（2）每次从未访问过的顶点中，选择一个与源点距离最短的一个顶点（记作u），访问该顶点。</p><p>（3）令该顶点u为中介点，优化源点与所有从顶点u出发能到达的顶点v之间的最短距离。</p><p>代码实现（未优化的原始版本）（用邻接矩阵储存图）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int INF = 0x3f3f3f3f;const int maxn = 107;int n, d[maxn]{};int G[maxn][maxn]{};bool vis[maxn]{};void Dijkstra(int s) //s为源点{memset(vis, false, sizeof(vis)); //初始化fill(d, d + maxn, INF);d[s] = 0;for (int i = 0; i &lt; n; i++){int u = -1, MIN = INF; //寻找最小距离的顶点ufor (int j = 0; j &lt; n; j++){if (!vis[j] &amp;&amp; d[j] &lt; MIN){u = j;MIN = d[j];}}if (u == -1)return; //剩下的点和顶点不连通vis[u] = true;for (int v = 0; v &lt; n; v++) //u作为中介点优化最短距离            //如果使用的是邻接表储存只有这句话需要改动{if (!vis[v] &amp;&amp; G[u][v] != INF){if (d[u] + G[u][v] &lt; d[v])d[v] = d[u] + G[u][v];}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码一个很好理解，就是把提到的具体实现改写成了代码。</p><p>再来看看复杂度，明显达到了O（2*n^2）的级别。那么考虑如何优化代码，将时间复杂度降低下来。</p><p>显然，最外面的for循环来标记每一个顶点已被访问是必不可少的，寻找最小距离的顶点u是可以优化的，通常使用堆优化来降低时间复杂度。最简洁的方法自然是采用STL中的容器priority_queue来实现（每次弹出的元素一定是整个队列中最小的元素）。</p><p>堆优化代码：（使用邻接表储存图进一步优化时间复杂度）</p><p>（在n的数量级&gt;=1e5时必须采用这种堆优化+邻接表方式 ）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int maxn = 107;struct edge {int to;int val;};int n, d[maxn]{};vector&lt;edge&gt;G[maxn];bool vis[maxn]{};void Dijkstra(int s){priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt;pq;memset(vis, 0, sizeof(vis));fill(d, d + maxn, INF);pii p;p.first = 0; p.second = s;pq.push(p);while (!pq.empty()){p = pq.top();pq.pop();int u = p.second;if (vis[u])continue;vis[u] = 1;for (int i = 0; i &lt; G[u].size(); i++){int v = G[u][i].to;if (d[v] &gt; d[u] + G[u][i].val){d[v] = d[u] + G[u][i].val;pq.push(pii(d[v], v));}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细细感受一下朴素算法和堆优化算法的区别，本质上其实是一模一样的。</p><p>特别注意：<strong>Dijkstra算法只能应对所有边权都是非负的情况！</strong></p><p>上面提到的都是最短距离的求解，下面将提到如何求解最短的路径。</p><p>很显然，要得到最短路径，终点和起点是已知的，缺少的自然是中间的结点，要得到这些中间结点，自然而然会选择在以u为中介优化的部分来做文章。所以我们可以用一个数组pre来记录前驱结点的编号，在优化的时候赋值即可。</p><p>代码实现也非常简单</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int INF = 0x3f3f3f3f;const int maxn = 107;int n, d[maxn]{};int G[maxn][maxn]{};bool vis[maxn]{};int pre[maxn]{};void Dijkstra(int s) {memset(vis, false, sizeof(vis)); fill(d, d + maxn, INF);d[s] = 0;for (int i = 0; i &lt; n; i++){int u = -1, MIN = INF;for (int j = 0; j &lt; n; j++){if (!vis[j] &amp;&amp; d[j] &lt; MIN){u = j;MIN = d[j];}}if (u == -1)return;vis[u] = true;for (int v = 0; v &lt; n; v++) {if (!vis[v] &amp;&amp; G[u][v] != INF){if (d[u] + G[u][v] &lt; d[v])                {                    d[v] = d[u] + G[u][v];                    pre[v]=u;                }}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到前驱数组pre后，利用dfs（在这里也就是递归的方法）来实现路径的输出。</p><p>代码非常简单：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pre[maxn]{};void dfs(int s, int u){if (u == s) //边界{cout &lt;&lt; s;return;}dfs(s, pre[u]);cout &lt;&lt; u; //从最深处回来的时候输出路径上的结点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，Dijkstra算法的核心部分内容就差不多结束了，但是题目考查形式绝对不会赤裸裸，一定要注意其变化（通常会加上第二标度），但抽丝剥茧后，一定都有一个共同点：单源！！！</p><p>例题：</p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805073643683840">原题链接</a></p><p>题意：（中文题面很好理解）n个顶点，m条无向边，每个点的点权已知。给出起点和终点，求从起点到终点是最短路径条数及最短路径上的最大点权和。</p><p>思路：这题除了求解最短路径和最短距离外还要求求解最短路径条数和最大点权和，则在上面的代码中需要添加额外的信息来记录这两个量。w数组记录起点到其他点的最大点权之和；num数组记录起点到其他点的最短路径条数。n的范围在0-500，所以可以采用邻接矩阵的方式来存储图。</p><p>AC代码：（该题包括上面提及的所有内容，综合考查Dijkstra算法）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define FI freopen("in.txt", "r", stdin)#define FO freopen("out.txt", "w", stdout)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef list&lt;int&gt;::iterator lii;typedef vector&lt;int&gt;::iterator vii;const int INF = 0x3f3f3f3f;const int mod = 998244353;const int maxn = 507;int miin = INF, maax = -1;int n, m, s, d;int G[maxn][maxn]{};int w[maxn]{}, max_w[maxn]{};int num[maxn]{}, pre[maxn]{};bool vis[maxn]{};int D[maxn]{};void Dij(){memset(vis, 0, sizeof(vis));memset(max_w, 0, sizeof(max_w));memset(num, 0, sizeof(num));fill(D, D + maxn, INF);D[s] = 0;max_w[s] = w[s];num[s] = 1;for (int i = 0; i &lt; n; i++){int u = -1, MIN = INF;for (int j = 0; j &lt; n; j++){if (!vis[j] &amp;&amp; D[j] &lt; MIN){u = j;MIN = D[j];}}if (u == -1)return;vis[u] = 1;for (int v = 0; v &lt; n; v++){if (!vis[v] &amp;&amp; G[u][v] != INF){if (G[u][v] + D[u] &lt; D[v]){D[v] = D[u] + G[u][v];pre[v] = u;num[v] = num[u];max_w[v] = max_w[u] + w[v];}else if (G[u][v] + D[u] == D[v]){if (max_w[u] + w[v] &gt; max_w[v]){max_w[v] = max_w[u] + w[v];pre[v] = u;}num[v] += num[u];}}}}}void dfs(int x){if (x == s){cout &lt;&lt; s &lt;&lt; " ";return;}dfs(pre[x]);if (x != d)cout &lt;&lt; x &lt;&lt; " ";else cout &lt;&lt; x &lt;&lt; endl;}int main() {std::ios::sync_with_stdio(false);std::cin.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;for (int i = 0; i &lt; n; i++)cin &gt;&gt; w[i];fill(G[0], G[0] + maxn * maxn, INF);for (int i = 0; i &lt; m; i++){int x, y, z;cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;G[x][y] = z;G[y][x] = z;}Dij();cout &lt;&lt; num[d] &lt;&lt; " " &lt;&lt; max_w[d] &lt;&lt; endl;dfs(d);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><h1 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h1><h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><p>Floyd算法读作弗洛伊德算法。</p><p>Floyd算法用来解决<strong>全源最短路问题</strong>，也即求解给定图中任意两点之间的最短路问题，时间复杂度是O（n^3）的级别。所以顶点数通常在200以内才会选择Floyd算法，因为顶点数不多，所以通常使用邻接矩阵来实现Floyd算法。</p><p>有类似于Dijkstra算法的基础，同样的道理，可以借助第三点k点作为中介点来对u、v两点之间的距离进行一个优化，非常好理解，所以我们通过枚举中介点1-n（n为图的顶点数）来进行全源最短路的优化。</p><p>代码非常好写：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 107int n, m;int d[maxn][maxn]{};int pre[maxn][maxn]{};void Floyd(){for (int k = 0; k &lt; n; k++){for (int i = 0; i &lt; n; i++){for (int j = 0; j &lt; n; j++){if (d[i][k] != INF &amp;&amp; d[k][j] != INF){if (d[i][k] + d[k][j] &lt; d[i][j]){d[i][j] = d[i][k] + d[k][j];pre[i][j] = k;}}}}}}int main() {std::ios::sync_with_stdio(false);std::cin.tie(0);fill(d[0], d[0] + maxn * maxn, INF);cin &gt;&gt; n &gt;&gt; m;//顶点数与边数for (int i = 1; i &lt; n; i++)d[i][i] = 0;for (int i = 0; i &lt; m; i++){int x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;d[x][y] = w;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意使用Floyd算法的条件是顶点数在200以内，因为算法的时间复杂度为O（n^3）,对于顶点数过多的题目，则不宜使用Floyd算法进行求解。</p><p>END</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="最短路径" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    
    <category term="大一" scheme="https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"/>
    
    <category term="图论" scheme="https://heekaai.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://heekaai.github.io/posts/5.html"/>
    <id>https://heekaai.github.io/posts/5.html</id>
    <published>2022-03-12T07:12:31.911Z</published>
    <updated>2022-03-22T02:28:27.009Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>并查集是一种维护集合的数据结构，用以解决动态连通性问题。顾名思义，“并”—“合并”—“Union”；“查”—“查找”—“Find”；“集”—“集合”—“Set”。主要需要支持查找和合并两个操作。</p><p>通常而言，并查集使用一个数组来实现：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int father[N];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数组含义如下：</p><p>$father[i]$表示元素 i 的父亲结点，其父亲结点也一定是这个集合里的元素。特别的，如果$father[i]=i$,则说明元素i是该集合的根节点，且对同一个集合只存在一个根节点，所以根节点也是这个集合的一个重要标识。</p><h1 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h1><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int father[N]{};void init(){for(int i=1;i&lt;N;i++)father[i]=i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化每一个元素都是根节点，独立成一个元素。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>通过递归实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int find_root(int x){if(x==father[x])return x;else return find_root((father[x]));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并是指把两个集合合并成一个集合，<strong>只有两个集合是不同集合时，才能够合并。</strong>合并的过程是把一个集合的根节点的父亲指向另一个集合的根节点。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Union(int a,int b){int faA=find_root(a);int faB=find_root(b);if(faA==faB)return;father[faB]=faA;  //father[faA]=faB也是可以的}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别注意：</p><ol><li>一定是根节点和根节点的互相指向关系。</li><li>不能对同一个集合的元素进行合并操作，否则将会产生一个闭环，从而破坏了其本身作为“树”的结构。</li></ol><h1 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h1><p>上面并合集的基本操作都非常简单，所以不做过多解释。现在考虑一个问题：对于一个链型的数据集合，要查找链条中的最后一个元素的父亲根结点，时间复杂度达到了O（N），这显然是无法接受的。所以我们应该想办法将其优化。</p><p><img src="https://s1.ax1x.com/2022/03/12/b787gU.jpg" alt="路径压缩"></p><p>这样处理之后，每一个子元素的查询时间复杂度是不是就可以降至O（1）。</p><p>现在，只需要把这样的处理改写成代码即可。</p><p>还是递归的写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int find_root(int x){if(x==father[x])return x;else{int F=find_root(father[x]); //寻找到根结点father[x]=F;return F;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在寻找的时候，实现了路径上的元素的路径压缩。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>放上一道例题（并查集的裸题）：</p><p><a href="https://codeforces.com/problemset/problem/277/A">Learning Languages</a></p><p><em>题目描述：</em></p><p>一个公司有n个员工，会使用m种语言，给出每个人会使用的语言（可以一种都不会），每个人学习不会的语言会花费1个单位的钱，为了让任意两个员工都能够交流（其他员工可以当他们的翻译），现在要求求出最小花费。</p><p><em>思路</em>：</p><p>并查集的思路，最后数出有多少根节点即可。（详细的结合代码理解）</p><p>AC代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 107;int t, n, m;int num[maxn]{};  /*num[i]的含义：第i种语言，员工num[i]第一个掌握（输入顺序的第一），后面出现                     会这种语言的自然是他的子节点*/int father[maxn]{};void init(){for (int i = 0; i &lt; maxn; i++)father[i] = i;}int find_root(int x){if (x == father[x])return x;else return find_root((father[x]));}void _union(int a, int b){int faA = find_root(a);int faB = find_root(b);if (faA == faB)return;father[faB] = faA;}int main(){std::ios::sync_with_stdio(false);std::cin.tie(0);cin &gt;&gt; n &gt;&gt; m;int ans = 0;memset(num, 0, sizeof(num));init();for (int i = 1; i &lt;= n; i++){int t;cin &gt;&gt; t;while (t--){int x;cin &gt;&gt; x;if (num[x] == 0)num[x] = i;else {if (i == father[i]){father[i] = num[x];}else{int F1 = find_root(i);int F2 = num[x];_union(F1, F2); //该员工当翻译，合并两个集合}}}}bool all0 = 1;for (int i = 1; i &lt;= m; i++){if (num[i] != 0){all0 = 0;break;}}if (all0){cout &lt;&lt; n &lt;&lt; endl;return 0;}for (int i = 1; i &lt;= n; i++){if (i == father[i])ans++;}ans--;cout &lt;&lt; ans &lt;&lt; endl;return 0;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运用的函数都是上文提到过的，此题查找部分不需要压缩路径（数据范围很小），特别注意最后的all0的特判（没有人会公司的官方语言）。</p><hr><p><strong>END</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="动态连通性问题" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="大一" scheme="https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"/>
    
    <category term="数据结构" scheme="https://heekaai.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>扩展欧几里得算法和中国剩余定理</title>
    <link href="https://heekaai.github.io/posts/4.html"/>
    <id>https://heekaai.github.io/posts/4.html</id>
    <published>2022-03-08T11:44:14.111Z</published>
    <updated>2022-03-12T09:26:28.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><p>扩展欧几里得算法就是对ax+by=gcd（a，b）的求解</p><p>问题引入：给定两个整数a和b，求一组解（x，y）使得等式ax+by=gcd（a，b）成立。（解一定存在的，有定理证明过）</p><p>回顾一下欧几里得算法（辗转相除法）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int gcd(int a,int b){    if(b==0)return a;    else return gcd(b,a%b);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（为了不弄混淆，记g=gcd（a，b），这里的a和b是最初的值）</p><p>观察跳出函数时的情况，a=g，b=0；此时x=1，y=0则是方程的解。按照这样的思路，是不是只要反推就可以得到最初的x，y的值。</p><p>下面是得到递推式的推导过程</p><p><img src="https://s1.ax1x.com/2022/03/08/bc1t1O.jpg" alt="推导过程"></p><p>现在有了递推边界和递推式，就可以得到求解的代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int ex_gcd(int a, int b, int&amp; x, int&amp; y)  //利用引用，直接修改x、y的值{if (b == 0)  //递归边界{x = 1;y = 0;return a;  //a=g}int g = ex_gcd(b, a % b, x, y);int temp = x;x = y;y = temp - a / b * y;return g;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>纯净版：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int ex_gcd(int a, int b, int&amp; x, int&amp; y){if (b == 0){x = 1;y = 0;return a;}int g = ex_gcd(b, a % b, x, y);int temp = x;x = y;y = temp - a / b * y;return g;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>符号和上述推导一致，应该很容易看明白。由于x，y是引用，故函数结束时x，y的值就是一组解；得到一组解就很容易将其推广到无数组解：</p><p><img src="https://s1.ax1x.com/2022/03/08/bcGjbQ.jpg" alt="推导过程"></p><p>扩展欧几里得算法的应用：</p><ol><li>ax+by=c的求解</li><li>同余式的求解</li><li>逆元的求解</li></ol><h1 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h1><p>问题引入：已知一个数除以3余2，除以5余3，除以7余2，求解这个数。（孙子问题的白话版）</p><script type="math/tex; mode=display">\begin{cases}n1=k1*3+2\\n2=k2*5+3\\n3=k3*7+2\\x=n1+n2+n3\end{cases}</script><ol><li><p>n1除以3余2，且是5,7的公倍数 ==》n1=35</p></li><li><p>n1除以5余3，且是3,7的公倍数 ==》n1=63</p></li><li><p>n1除以7余2，且是3,5的公倍数 ==》n1=30</p><p>则x=（35+63+30）= 128</p></li></ol><script type="math/tex; mode=display">x_{min}=x_{now}\%gcd(3,5,7)=128\%105=23</script><p>这就是著名的的孙子问题。我们再来看中国剩余定理的定义：</p><p>设正整数$m1,m2,······,mk$ 两两互素，则同余方程组：</p><script type="math/tex; mode=display">\begin{cases}x\equiv a_{1}(mod\ m_{1})\\x\equiv a_{2}(mod\ m_{2})\\······\\x\equiv a_{k}(mod\ m_{k})\\\end{cases}</script><p><strong>一定会有整数解</strong>，并且在模M（$M=\prod_{i=1}^{m}m_i$）下的解是惟一的，x的值为：</p><script type="math/tex; mode=display">x\equiv (a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+···+a_kM_kM_k^{-1})\ mod\ M</script><p>其中$M_i={M\over m_i}$ ,而$M_i^{-1}为M_i模m_i的逆元$ </p><p>上面就是中国剩余定理的完整描述，也就可以得到下面的代码模板了：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//情况一：n个数互质const int maxn = 2007 ;int a[maxn], m[maxn], n;int CRT(){int M = 1;for (int i = 0; i &lt; n; i++)M *= m[i];int ret = 0;for (int i = 0; i &lt; n; i++){int x, y;int tm = M / m[i];ex_gcd(tm, m[i], x, y);ret = (ret + tm * x * a[i]) % M;}return (ret + M) % M;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在把情况更加一般化，如果n个数不互质呢，其实也是可以转化的，（证明省略），直接上代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//情况二：n个数不互质int a[maxn], m[maxn], n;int CRT(){if (n == 1){if (m[0] &gt; a[0])return a[0];else return -1;}int x, y, d;for (int i = 1; i &lt; n; i++){if (m[i] &lt;= a[i])return -1;d = ex_gcd(m[0], m[i], x, y);if ((a[i] - a[0]) % d != 0)return -1;int t = m[i] / d;x = ((a[i] - a[0]) / d * x % t + t) % t;a[0] = x * m[0] + a[0];m[0] = m[0] * m[i] / d;a[0] = (a[0] % m[0] + m[0]) % m[0];}return a[0];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>END</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="基础" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CRT模板" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="扩展欧几里得" scheme="https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
    
    <category term="大一" scheme="https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"/>
    
    <category term="模板" scheme="https://heekaai.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>STL入门--algorithm头文件</title>
    <link href="https://heekaai.github.io/posts/3.html"/>
    <id>https://heekaai.github.io/posts/3.html</id>
    <published>2022-02-18T02:51:59.312Z</published>
    <updated>2022-03-02T08:36:37.022Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="algorithm头文件下的常用函数"><a href="#algorithm头文件下的常用函数" class="headerlink" title="algorithm头文件下的常用函数"></a>algorithm头文件下的常用函数</h1><p>前提：添加algorithm头文件</p><hr><h2 id="max（）、min（）和abs（）"><a href="#max（）、min（）和abs（）" class="headerlink" title="max（）、min（）和abs（）"></a>max（）、min（）和abs（）</h2><p>max（x，y）和min（x，y）分别返回x和y中的最大值和最小值，且参数必须是两个（可以是浮点数）。如果想要返回三个数x、y、z的最大值，可以通过max（x，max（y，z））的写法。</p><p>abs（x）返回x的绝对值。注意：x必须是整数，浮点型的绝对值请用math头文件下的fabs。</p><h2 id="swap（）"><a href="#swap（）" class="headerlink" title="swap（）"></a>swap（）</h2><p>swap（x，y）用以交换x和y的值</p><h2 id="reverse（）"><a href="#reverse（）" class="headerlink" title="reverse（）"></a>reverse（）</h2><p>reverse（it1，it2）可以将数组指针在[ it1, it2 ）之间的元素或迭代器在[ it1, it2 ）范围内的元素进行反转。（左闭右开的特点）示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(){vector&lt;int&gt;ve;int num[9];for (int i = 0; i &lt; 6; i++){num[i] = i;ve.push_back(i);}vector&lt;int&gt;::iterator it=ve.begin();reverse(it + 1, it + 4);reverse(num + 1, num + 4);for (int i = 0; i &lt; 6; i++){cout &lt;&lt; ve[i] &lt;&lt; " ";}cout &lt;&lt; endl;for (int i = 0; i &lt; 6; i++){cout &lt;&lt; num[i] &lt;&lt; " ";}cout &lt;&lt; endl; //输出：0 3 2 1 4 5return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="next-permutation（）"><a href="#next-permutation（）" class="headerlink" title="next_permutation（）"></a>next_permutation（）</h2><p>next_permutation（）给出一个序列在全排列中的下一个序列。</p><p>全排列是按照字典序由小至大的顺序进行排序。</p><p>并且值得注意的是其返回值，若存在下一个排序，返回值是true；若不存在最后一个排序（即当前为最后一个全排列），返回值则为false。根据这一特性，通常会使用do···while···循环来实现全排列。</p><p>下面是1-9全排列的代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main (){    int num[9];    for(int i=0;i&lt;9;i++)    num[i]=i+1;    do{        for(int i=0;i&lt;9;i++)        cout&lt;&lt;num[i]&lt;&lt;" ";        cout&lt;&lt;endl;    }while(next_permutation(num,num+9));    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="fill（）"><a href="#fill（）" class="headerlink" title="fill（）"></a>fill（）</h2><p>fill（）函数可以将数组或容器某区间内所有元素全部赋值为同一值，用法和memset类似，但是fill（）函数的赋值可以是数据范围内的一值。</p><p>具体用法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">fill(it1,it2,num)；    //it可以是指针或者是迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="sort（）"><a href="#sort（）" class="headerlink" title="sort（）"></a>sort（）</h2><p>顾翻译思义，sort就是用来排序的函数，效率较高。相比于C语言中的qsort函数，sort函数用起来更加便捷，并且规避某些效率特别低的情况。</p><h3 id="sort函数的三个参数"><a href="#sort函数的三个参数" class="headerlink" title="sort函数的三个参数"></a>sort函数的三个参数</h3><ol><li><p>第一个是要排序的数组的起始地址。</p></li><li><p>第二个是结束的地址（最后一位要排序的地址）的下一个地址</p></li><li><p>比较函数</p><p>其中第三点非必填内容，若不填，则默认递增的顺序</p><p>一定特别需要注意的是：“左闭右开”第二个参数是末尾元素的下一个地址</p></li></ol><h3 id="比较函数cmp的书写"><a href="#比较函数cmp的书写" class="headerlink" title="比较函数cmp的书写"></a>比较函数cmp的书写</h3><p>cmp函数的书写就好比人为给sort（）函数制定比较规则一样，让sort（）函数按照自己的想法进行排序。</p><ol><li><p>基本数据类型</p><p>基本数据类型本身就具有可比性，则默认即为增序。只需记忆递减的情形下的cmp函数。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;bool cmp(int a, int b){return a &gt; b;}int main(){int num[5]{3,8,1,2,4};for (int i = 0; i &lt; 5; i++)cout &lt;&lt; num[i] &lt;&lt; " ";//输出：3 8 1 2 4cout &lt;&lt; endl;sort(num, num + 5);for (int i = 0; i &lt; 5; i++)cout &lt;&lt; num[i] &lt;&lt; " ";//输出： 1 2 3 4 8cout &lt;&lt; endl;sort(num, num + 5, cmp);for (int i = 0; i &lt; 5; i++)cout &lt;&lt; num[i] &lt;&lt; " ";//输出： 8 4 3 2 1cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他数据类型同理可知。</p></li><li><p>结构体数组的排序</p><p>结构体本身并无直接可比性，所以就没有默认排序一说，都需要通过书写cmp函数来实现人为制定比较规则。</p><p>一级排序：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;struct test{int x, y;}ss[5];bool cmp(test a, test b){return a.x &lt; b.x;//“&lt;”从小至大 “&gt;”从大至小}int main(){for (int i = 0; i &lt; 5; i++){ss[i].x = rand()%17;ss[i].y = rand()%17;//随机数}for (int i = 0; i &lt; 5; i++){cout &lt;&lt; ss[i].x &lt;&lt; " " &lt;&lt; ss[i].y &lt;&lt; endl;}cout &lt;&lt; endl;sort(ss, ss + 5, cmp);for (int i = 0; i &lt; 5; i++){cout &lt;&lt; ss[i].x &lt;&lt; " " &lt;&lt; ss[i].y &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显可以发现，一级排序仅仅只会排序结构体中的第一个变量，若想实现第二个变量的排序，只需改变cmp函数的写法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool cmp(test a, test b){if (a.x != b.x)return a.x &lt; b.x;else return a.y &gt; b.y;}//x从小到大，y从大到小的顺序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的可以进行扩展。</p></li><li><p>STL容器的排序</p><p>前提：STL容器中只有vector、string、deque才可以使用sort函数进行排序</p><p>用法类似于数组，牢记“左闭右开”的规则。</p></li></ol><h2 id="lower-bound（）和upper-bound（）"><a href="#lower-bound（）和upper-bound（）" class="headerlink" title="lower_bound（）和upper_bound（）"></a>lower_bound（）和upper_bound（）</h2><p>前提：数组或容器本身是有序的</p><p>lower_bound（left，right，num）用来在容器或数组的[left，right）中查找<strong>第一个大于或等于</strong>num的元素的位置。若为数组，返回指针；若为容器，返回迭代器。</p><p>相应的，upper_bound（）函数的作用是查找第一个大于num的元素的位置。</p><p>换言之，假设本身数组或容器内不存在该元素，两个函数均返回可以插入该元素的位置。（即若存在，应该在哪个位置）</p><p>小技巧：通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>前提：针对从大到小排序的数组或容器，利用重载来实现查找</p><p>大同小异：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">lower_bound(left,right,num,greater&lt;type&gt;());//查找第一个小于或等于num的元素位置upper_bound(left,right,num,greater&lt;type&gt;());//查找第一个小于num的元素位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;bool cmp(int a, int b){return a &gt; b;}int main(){int a[9]{};for (int i = 0; i &lt; 9; i++)a[i] = rand() % 5 + 1;sort(a, a + 9);for (int i = 0; i &lt; 9; i++)cout &lt;&lt; a[i] &lt;&lt; " ";cout &lt;&lt; endl;int pos1 = lower_bound(a, a + 9, 3) - a;cout &lt;&lt; pos1 &lt;&lt; " ";int pos2 = upper_bound(a, a + 9, 3) - a;cout &lt;&lt; pos2 &lt;&lt; endl;sort(a, a + 9, cmp);for (int i = 0; i &lt; 9; i++)cout &lt;&lt; a[i] &lt;&lt; " ";cout &lt;&lt; endl;pos1 = lower_bound(a, a + 9, 3,greater&lt;int&gt;()) - a;cout &lt;&lt; pos1 &lt;&lt; " ";pos2 = upper_bound(a, a + 9, 3,greater&lt;int&gt;()) - a;cout &lt;&lt; pos2 &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：</p><h2 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h2><p>partial_sum 是C++ STL 算法组件中的其中一个算法，其作用是计算某个序列局部元素的和。它有四个重载函数。要使用 partial_sum 需要引用头文件 numeric。</p><p>一般来说，使用partical_sum函数需要四个参数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">partial_sum(容器要计算的起始位置，容器要计算的结束位置，结果存放的起始位置，自定义函数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中自定义函数可以留白，则默认计算局部和。而且，结果可以存放在原容器内。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;numeric&gt;using namespace std;int cmp(int x, int y) {return x - y;}int main () {int test[10];int ans[10];for (int i = 0; i &lt; 10; i++)test[i] = rand() % 57;for (int i = 0; i &lt; 10; i++)cout &lt;&lt; test[i] &lt;&lt; " ";cout &lt;&lt; endl;partial_sum(test, test + 10, ans);for (int i = 0; i &lt; 10; i++)cout &lt;&lt; ans[i] &lt;&lt; " ";cout &lt;&lt; endl;partial_sum(test, test + 10, test, cmp);for (int i = 0; i &lt; 10; i++)cout &lt;&lt; test[i] &lt;&lt; " ";cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><p><img src="https://s4.ax1x.com/2022/03/02/b8sFRs.png" alt=""></p><p>可以很直接看到用法，此函数通常可以用于前缀和，减少代码量。</p><h2 id="max-element和min-element"><a href="#max-element和min-element" class="headerlink" title="max_element和min_element"></a>max_element和min_element</h2><p>作用：返回最大值和最小值的地址</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main () {int test[10];for (int i = 0; i &lt; 10; i++)test[i] = rand() % 57;for (int i = 0; i &lt; 10; i++)cout &lt;&lt; test[i] &lt;&lt; " ";cout &lt;&lt; endl;cout &lt;&lt; max_element(test, test + 10) &lt;&lt; endl;//输出地址cout &lt;&lt; *max_element(test, test + 10) &lt;&lt; endl;//输出元素cout &lt;&lt; max_element(test, test + 10) - test &lt;&lt; endl;//输出在数组中的位置return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://s4.ax1x.com/2022/03/02/b8sPiQ.png" alt="运行结果"></p><p>END</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://heekaai.github.io/categories/C/"/>
    
    <category term="基础" scheme="https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="STL" scheme="https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"/>
    
    
    <category term="C++" scheme="https://heekaai.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://heekaai.github.io/tags/STL/"/>
    
    <category term="大一" scheme="https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"/>
    
    <category term="假期" scheme="https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>STL入门---容器篇</title>
    <link href="https://heekaai.github.io/posts/2.html"/>
    <id>https://heekaai.github.io/posts/2.html</id>
    <published>2022-01-30T13:15:10.000Z</published>
    <updated>2022-03-14T06:35:28.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>此文介绍STL中的容器部分，仅仅涉及入门知识及一些常见的用法。</p><hr><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>  vector 在英文中翻译为向量，但是在C++中把它叫做“变长数组”，更加容易理解它的用法。顾名思义：vector容器是长度根据需要而自动改变的数组。</p><p>  如果要使用vector容器，需要在头文件里加上#include&lt; vector &gt;</p><h2 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h2><p>讲vector的定义之前，可以先回顾一下数组的定义方法。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typename arrayname[arraysize];  //一维数组typename arrayname[arraysize1][arraysize2];  //二维数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面再来看vector的定义：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;typename&gt; name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和一维数组一样，typename可以是所有的基本类型，例如：int、double、char、结构体······当然也可以是STL中的其他容器，例如：vector、set、queue······</p><p><strong>vector数组的定义</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;typename&gt; name[size];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; ve[100];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样ve[0]到ve[99]每一维都是一个vector容器。</p><p>当然，如果我们把typename也改成vector容器，同样可以实现二维数组的功能。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样数组的两个维度都是“变长”的。而vector\<typename\> name[size]其中一维的长度就已经固定了。稍微体会一下这两者的区别。</typename\></p><h2 id="访问vector容器中的元素"><a href="#访问vector容器中的元素" class="headerlink" title="访问vector容器中的元素"></a>访问vector容器中的元素</h2><p>vector容器有两种访问方式：通过下标或者迭代器访问。下面分别讲到这两种访问方式。</p><ol><li><p>通过下标访问</p><p>和访问普通的数组一样，对于一个定义为vector&lt;int&gt;ve的vector容器而言，直接访问ve[index]即可。当然这个下标访问和普通数组一样是从0~~ve.size（）-1，也需要注意存在越界的问题。</p></li><li><p>通过迭代器访问</p><p>迭代器（iterator）可以理解为一个类似于指针的东西，其定义为：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;typename&gt;::iterator it;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样定义之后 i t 就是vector\<typename\>::iterator 型的变量。也即迭代器 i t ，并且可以通过*i t来访问vector中的元素。</typename\></p><p>比如说：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main (){    vector&lt;int&gt; ve;    for(int i=0;i&lt;6;i++)    ve.push_back(i); //后面会提，在ve的末尾添加元素i    for(int i=0;i&lt;6;i++)    cout&lt;&lt;ve[i]&lt;&lt;" ";    cout&lt;&lt;endl;    vector&lt;int&gt;::iterator it=ve.begin(); //it指向ve的首地址    for(int i=0;i&lt;6;i++)    cout&lt;&lt;*(it+i)&lt;&lt;" ";    cout&lt;&lt;endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面给出的例程，可以看出<strong>ve[i]和*(it+i)是等价的</strong>。</p><p>上面的代码中出现了ve.begin（），其作用是取到vector容器的首地址。而ve.end（）却不是取到vector容器的末尾地址，而是末尾元素的下一个地址。</p><p>另外，需要注意的还有迭代器还支持自加和自减操作，则遍历vector容器还有第三种写法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main (){    vector&lt;int&gt; ve;    for(int i=0;i&lt;6;i++)    ve.push_back(i);     vector&lt;int&gt;::iterator it;    for(it=ve.begin();it!=ve.end();it++)    cout&lt;&lt;*it&lt;&lt;" ";    cout&lt;&lt;endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="vector容器的常用函数"><a href="#vector容器的常用函数" class="headerlink" title="vector容器的常用函数"></a>vector容器的常用函数</h2><ol><li><p><strong>push_back（）</strong></p><p>上面的代码就已经使用过这种方式添加过元素了。很简单，和函数名一样，push_back(x) 的作用就是在 vector 容器最后添加上元素 x ，时间复杂度是 O（1） 。</p></li><li><p><strong>pop_back（）</strong></p><p>有添加作用的函数自然，相对的肯定会有删减作用的函数。pop_back（） 用以删除vector容器中的最后一个元素，时间复杂度同样为 O（1）。</p><p>比如说：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main (){    vector&lt;int&gt; ve;    for(int i=1;i&lt;=5;i++)    {        ve.push_back(i);    }    vector&lt;int&gt;::iterator it;    for(it=ve.begin();it!=ve.end();it++)    {        cout&lt;&lt;*it;        cout&lt;&lt;" ";    }    putchar('\n');    ve.pop_back();    for(it=ve.begin();it!=ve.end();it++)    {        cout&lt;&lt;*it;        cout&lt;&lt;" ";    }    putchar('\n');    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol><li><p><strong>size（）</strong> </p><p>size（）函数用以获取vector容器中的元素个数。</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main (){    vector&lt;int&gt; ve;    for(int i=1;i&lt;=5;i++)    {        ve.push_back(i);    }    cout&lt;&lt;ve.size()&lt;&lt;endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><strong>clear（）</strong></p><p>clear（）用以清空vector容器中的所有元素，时间复杂度是 O（N) ，其中N是vector容器中的元素个数。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main (){    vector&lt;int&gt; ve;    for(int i=1;i&lt;=5;i++)    {        ve.push_back(i);    }    cout&lt;&lt;ve.size()&lt;&lt;endl; //输出5    ve.clear();    cout&lt;&lt;ve.size()&lt;&lt;endl; //输出0    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol><li><p><strong>insert（）</strong></p><p>insert（it,x）用以向vector容器的任意迭代器it位置插入一个元素x，时间复杂度为 O（N)。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main (){    vector&lt;int&gt; ve;    for(int i=1;i&lt;=5;i++)    {        ve.push_back(i);    }    vector&lt;int&gt;::iterator it;    for(it=ve.begin();it!=ve.end();it++)    {        cout&lt;&lt;*it&lt;&lt;" "; //输出1 2 3 4 5    }    cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl;    it=ve.begin()+2; //***    ve.insert(it,-1);    for(it=ve.begin();it!=ve.end();it++)    {        cout&lt;&lt;*it&lt;&lt;" "; //输出1 2 -1 3 4 5    }    cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>需要特别说明的是，代码中注释标注为三个<em>的地方，在常用的STL容器中，<em>*只有在string和vector中，才允许使用ve.begin（）+2这种迭代器直接加上整数的写法！</em></em></p><ol><li><p><strong>erase（）</strong></p><p>erase（）也是一种删除函数，它有两种使用方法：删除单个元素以及删除一个区间内的所有元素。时间复杂度自然也是 O（N)。</p><p>（1）删除单个元素：</p><p>erase（it）即删去迭代器 it 处的元素。</p><p>例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main (){    vector&lt;int&gt; ve;    for(int i=1;i&lt;=5;i++)    {        ve.push_back(i);    }    vector&lt;int&gt;::iterator it;    for(it=ve.begin();it!=ve.end();it++)    {        cout&lt;&lt;*it&lt;&lt;" "; //输出1 2 3 4 5     }    cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl;    it=ve.begin()+2;    ve.erase(it);    for(it=ve.begin();it!=ve.end();it++)    {        cout&lt;&lt;*it&lt;&lt;" "; //输出1 2 4 5    }    cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）删除一个区间内的所有元素</p><p>遵循着“左闭右开”的原则，erase（left,right）即删去[first,right)内vector容器中的所有元素。</p><p>示例如下：</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main (){    vector&lt;int&gt; ve;    for(int i=1;i&lt;=5;i++)    {        ve.push_back(i);    }    vector&lt;int&gt;::iterator it;    for(it=ve.begin();it!=ve.end();it++)    {        cout&lt;&lt;*it&lt;&lt;" "; //输出1 2 3 4 5     }    cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl;    ve.erase(ve.begin()+1,ve.begin()+4); //删去下标为[1,4)的元素    for(it=ve.begin();it!=ve.end();it++)    {        cout&lt;&lt;*it&lt;&lt;" "; //输出1 5    }    cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  所以清空vector容器除了上面提到的clear()函数外，现在也可以使用第二种方法：ve.erase（ve.begin（）,ve.end（））。这样只是加深对“左闭右开”的理解，因为ve.end（）指向的是末尾元素的下一个位置。当然clear（）函数明显更加方便、简洁。</p><hr><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>在C语言中，通常使用字符数组char s[] 来对字符串进行存储，在此基础上为了对字符串的操作更加的快捷、方便，C++在STL中加入了string类型，对字符串的常用功能进行了封装。如果要使用string，需要添加头文件\<string\><strong>（注意string.h和string是完全不一样的头文件）</strong>。下面来看看string容器的常用使用方法吧。</string\></p><h2 id="string的定义"><a href="#string的定义" class="headerlink" title="string的定义"></a>string的定义</h2><p>定义 string 的方式和其他的基本数据类型一致，只需要在 string 后面加上变量的名称即可。如果要进行初始化，定义时直接进行赋值即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str; //定义string str="abcd"; //赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="访问string容器中的元素"><a href="#访问string容器中的元素" class="headerlink" title="访问string容器中的元素"></a>访问string容器中的元素</h2><p>（1）通过下标访问：</p><p>一般而言，可以像访问字符数组那样通过下标对string容器进行访问。</p><p>（2）通过迭代器访问：</p><p>定义迭代器：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">string::iterator it; //string类型无其他参数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于使用迭代器对string容器中的元素进行访问的方法，类似于上文中的vector容器，在这里就不做过多阐述，可以参照上文。</p><p>如果要读入和输出整个字符串，则只能使用cin和cout。</p><p>最后需要注意的一点，string和vector一样，<strong>支持直接对迭代器进行加减某个数字</strong>，比如说str.begin（）+2 的写法是合法的。而对于STL的其他容器，则不支持这种写法。</p><h2 id="string容器的常用函数"><a href="#string容器的常用函数" class="headerlink" title="string容器的常用函数"></a>string容器的常用函数</h2><p>（1）比较与拼接</p><p>因为 string 在C++中是一种数据类型，则可以像其他的变量一样进行加法运算及比较运算（比较的是字典序）。比如说：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main (){    string str1="abc",str2="123";    string str;    str=str1+str2;    cout&lt;&lt;str&lt;&lt;endl; //输出abc123    string str3="aaabc",str4="aabc";    cout&lt;&lt;(str3&gt;str4)&lt;&lt;endl; //返回0，str3字典序大于str4    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）length（）和 size（）函数</p><p>这两个函数都是返回 string 的长度，作用和运行效率基本相同。</p><p>（3）insert（）函数</p><p>string的insert（）函数，常见的写法有两种。</p><p>①insert（pos，string），pos为string容器中的位置，string为待插入的字符串。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main (){    string str1="abcde",str2="123";    str1.insert(3,str2); //在str[3]处插入了“123”    cout&lt;&lt;str1&lt;&lt;endl; //输出abc123de}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②insert（it，it2，it3）使用三个迭代器的写法，it 指向原字符串待插入的位置，it1、it2指向待插字符串的首尾元素，来表示串 [ it1,it2 )插入到 it 位置。（左闭右开原则）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main (){    string str1="abcde",str2="123";    str1.insert(str1.begin()+3,str2.begin(),str2.end());    cout&lt;&lt;str1&lt;&lt;endl; //abc123de}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）erase（）函数</p><p>（5）clear（）函数</p><p>这两个函数用法和vector容器的用法一致，可以参照上文。</p><p>（6）substr（）函数</p><p>substr（pos，len）返回从pos号位置开始，长度为len的子串。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main (){    string str="Today is a nice day";    cout&lt;&lt;str.substr(0,5)&lt;&lt;endl; //输出Today    cout&lt;&lt;str.substr(11,4)&lt;&lt;endl; //输出nice}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（7）find（）函数</p><p>str.find（str1)，即在str中找是否存在子串str1，若存在则返回子串首次出现的位置，否则返回string::npos常数（最大的unsigned_int，也相当于-1。）</p><p>str.find（str1，pos)即将开始查找的位置定为pos，返回值和上面相同。</p><p>时间复杂度为 O（mn） 故使用需谨慎考虑时间复杂度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main (){    string str="Today is a nice day";    cout&lt;&lt;str.find("nice day")&lt;&lt;endl; //返回11    cout&lt;&lt;str.find("bad day")&lt;&lt;endl;    if(str.find("bad day")==-1)cout&lt;&lt;"-1"&lt;&lt;endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（10）replace（）函数</p><p>str.replace（pos，len，str1）把str的pos号位置开始，长度为len的子串替换为str1。</p><p>str.replace（it1，it2，str1）把str [ it1，it2 ) 替换为str1。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main (){    string str="Today is a bad day";    cout&lt;&lt;str&lt;&lt;endl;    string str1="nice",str2="Tomorrow";    str.replace(11,3,str1);    cout&lt;&lt;str&lt;&lt;endl; //输出 Today is a nice day    str.replace(str.begin(),str.begin()+5,str2);    cout&lt;&lt;str&lt;&lt;endl; //输出 Tomorrow is a nice day}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（11）字符串和数字的相互转换</p><ol><li><p>数字-&gt;字符串（to_string函数）</p><p>to_string（val）val的值能够自动判别类型，返回值是string；</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main (){string s1,s2;int x=4595;s1=to_string(x);cout&lt;&lt;s1&lt;&lt;endl;long long y=123456789101112;s2=to_string(y);cout&lt;&lt;s2&lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串-&gt;数字</p><p>常用的有stoi（）、stoll（）、stof（）、stod（），分别将字符串转化为int、long long、float、double类型的数字。依葫芦画瓢，其他类型同样是这样的形式。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main (){string s1,s2;s1="3.14159";double pi=stod(s1);cout&lt;&lt;pi&lt;&lt;endl;s2="1234567891011121314";long long x=stoll(s2);cout&lt;&lt;x&lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set在英文中翻译为集合，<strong>是一个内部自动有序且不含重复元素的容器</strong>。如果要使用set容器，则需要在头文件中添加&lt; set &gt;。</p><h2 id="set的定义"><a href="#set的定义" class="headerlink" title="set的定义"></a>set的定义</h2><p>set的定义的写法其实和vector基本上是一样的，或者说大部分STL容器都是这样定义的。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;set&gt; //记得添加头文件using namespace std;int main (){    set&lt;typename&gt; name;  //一维    set&lt;typename&gt; arrayname[arraysize];  //二维}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="set容器内元素的访问"><a href="#set容器内元素的访问" class="headerlink" title="set容器内元素的访问"></a>set容器内元素的访问</h2><p>set 容器内的元素只能通过迭代器进行访问。且 set 容器不支持*（it+i）的访问方式，因此常用的枚举方式如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;set&gt; //记得添加头文件using namespace std;int main (){    set&lt;int&gt; st; //定义set容器    st.insert(2); //用insert插入元素    st.insert(1);    st.insert(3);    st.insert(2);    set&lt;int&gt;::iterator it; //定义迭代器    for(it=st.begin();it!=st.end();it++)    cout&lt;&lt;*it&lt;&lt;" "; //输出1 2 3     cout&lt;&lt;endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果可以发现，set容器内部自动实现了递增排序且删除了重复的元素。</p><h2 id="set容器常用函数"><a href="#set容器常用函数" class="headerlink" title="set容器常用函数"></a>set容器常用函数</h2><ol><li><p>insert（）</p><p>insert（x）可将x插入容器中，且实现自动升序和去重，时间复杂度是O（logN）其中 N 是当前容器中的元素个数。</p></li><li><p>find（）</p><p>find（x）返回set容器中对应值为x的迭代器（而不是下标 string返回的是对应下标），时间复杂度是O（logN）其中 N 是当前容器中的元素个数。</p></li><li><p>earse（）</p><p>同样，erase函数有两种用法：单个元素和区间元素删除。</p><p>（1）删除单个元素：</p><p>erase（it）即删去迭代器 it 处的元素。可结合find（）函数进行使用。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;set&gt; //记得添加头文件using namespace std;int main (){    set&lt;int&gt; st;    for(int i=1;i&lt;5;i++)    st.insert(i);    set&lt;int&gt;::iterator it;    it=st.find(3);    st.erase(it);    for(it=st.begin();it!=st.end();it++)    cout&lt;&lt;*it&lt;&lt;" "; //输出1 2 4    cout&lt;&lt;endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>erase（value），value为待删除元素的值。时间复杂度为O（N)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;set&gt; //记得添加头文件using namespace std;int main (){    set&lt;int&gt; st;    for(int i=1;i&lt;5;i++)    st.insert(i);    set&lt;int&gt;::iterator it;    st.erase(3);    for(it=st.begin();it!=st.end();it++)    cout&lt;&lt;*it&lt;&lt;" "; //输出1 2 4    cout&lt;&lt;endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）删除一个区间内的所有元素</p><p>用法和上文提到的vector容器的用法一致，可以参照上文。</p></li><li><p>size（）</p></li><li><p>clear（）</p><p>用法同样是类似的，在这里就不做过多的阐述了。</p></li></ol><hr><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map在英文中翻译为映射，也是常用的STL容器。</p><p> 一个简单的引入：在定义数组时（比如说int array[ 100 ]),其实就可以理解为一个int -&gt; int 的映射。而map容器则可以将任何数据类型映射到任何数据类型（当然也包括STL容器）。</p><h2 id="map容器的定义"><a href="#map容器的定义" class="headerlink" title="map容器的定义"></a>map容器的定义</h2><p>单独定义一个map：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">map&lt;typename1,typename2&gt; mp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们把映射前类型称为键（key），映射后类型称为值（value）。</p><p>特别说明：当字符串作为键值时，不能使用char[ ]型的数组，而应该是使用string容器。并且，map中的键是唯一的，和数学中的映射概念是一致的。</p><h2 id="map容器内元素的访问"><a href="#map容器内元素的访问" class="headerlink" title="map容器内元素的访问"></a>map容器内元素的访问</h2><p>map容器一般有两种访问方式：通过下标访问或通过迭代器访问。下面来讨论这两种访问方式。</p><p>（1）通过下标访问</p><p>和引入部分提到的，就和访问普通的数组是一样的，可以通过下标进行赋值和访问。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;map&gt; //记得添加头文件using namespace std;int main (){    map&lt;char,int&gt;mp;    char ch='a';    for(int i=1;i&lt;=26;i++)    {        mp[ch]=i; //赋值        ch++;    }    cout&lt;&lt;mp['h']&lt;&lt;" "&lt;&lt;mp['k']&lt;&lt;endl; //输出8 11    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）通过迭代器访问</p><p>map容器的迭代器定义方式和其他STL容器迭代器定义方式相同。</p><p>但是因为在定义时有两个数据类型，所以在使用map容器的迭代器时，可以使用 it -&gt; first 来访问键，使用 it -&gt; second 来访问值。</p><p>例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main (){    map&lt;char,int&gt;mp;    char ch='a';    for(int i=1;i&lt;=5;i++)    {        mp[ch]=i;        ch++;    }    map&lt;char,int&gt;::iterator it;    for(it=mp.begin();it!=mp.end();it++)    {        cout&lt;&lt;it -&gt; first&lt;&lt;" "&lt;&lt;it -&gt; second&lt;&lt;endl;//输出a-e 1-5    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然上面代码赋值是从小到大，但是实际上map容器的键值会以从小到大的顺序自动排序（类似于 set容器内部使用红黑树来实现）。</p><h2 id="map容器常用函数"><a href="#map容器常用函数" class="headerlink" title="map容器常用函数"></a>map容器常用函数</h2><ol><li><p>find（）函数</p><p>find（key）返回键值为key的映射的迭代器，时间复杂度为O（logN）</p></li><li><p>erase（）函数</p><p>mp.erase（x）其中x可以为键值或者迭代器</p><p>区间删除类似于set容器，可以参照上文的set容器。</p></li><li><p>size（）函数</p><p>得到的是映射的对数</p></li><li><p>clear（）函数</p><p>用法同样类似，在此不做赘述。</p></li></ol><hr><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p> stack的英文翻译是栈，是STL中实现后进先出的容器。    </p><h2 id="stack定义"><a href="#stack定义" class="headerlink" title="stack定义"></a>stack定义</h2><p>stack定义方法和上面提到的容器类似，typename可以是任意的数据类型。使用stack容器时，头文件一定不要忘记添加#include&lt; stack &gt;</p><h2 id="stack容器内元素的访问"><a href="#stack容器内元素的访问" class="headerlink" title="stack容器内元素的访问"></a>stack容器内元素的访问</h2><p>由于stack容器后进先出的特性，故只能通过top（）来访问栈顶元素</p><p>简单例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main (){    stack&lt;int&gt; st;    for(int i=0;i&lt;5;i++)    st.push(i);    cout&lt;&lt;st.top()&lt;&lt;endl; //输出 4}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面这个例子不难看出stack容器后进先出的特性以及top（）函数的用法。</p><h2 id="stack容器常用函数的使用"><a href="#stack容器常用函数的使用" class="headerlink" title="stack容器常用函数的使用"></a>stack容器常用函数的使用</h2><ol><li><p>push（）</p><p>push（x）将元素x入栈，时间复杂度为 O（1）</p></li><li><p>top（）</p><p>获取栈顶元素</p></li><li><p>pop（）</p><p>弹出栈顶元素</p></li><li><p>empty（）</p><p>用以检查栈内元素是否为空，若为空即返回true，否则返回false。</p></li><li><p>size（）</p><p>返回容器内的元素个数</p></li></ol><hr><h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p> queue的英文翻译是队列，是STL中实现先进先出功能的容器。</p><h2 id="queue容器的定义"><a href="#queue容器的定义" class="headerlink" title="queue容器的定义"></a>queue容器的定义</h2><p>首先还是要提醒使用时记得添加头文件#includ&lt; queue &gt;，其余写法和其他的STL容器类似。</p><h2 id="queue容器内的元素访问"><a href="#queue容器内的元素访问" class="headerlink" title="queue容器内的元素访问"></a>queue容器内的元素访问</h2><p>参照栈，由于队列具有先进先出的特性，所以queue容器只允许通过front（）和back（）来访问队列中对首元素和队尾元素。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main (){    queue&lt;int&gt;q;    for(int i=0;i&lt;5;i++)    q.push(i);    cout&lt;&lt;q.front()&lt;&lt;" "&lt;&lt;q.back(); //输出： 1 5    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="queue常用函数"><a href="#queue常用函数" class="headerlink" title="queue常用函数"></a>queue常用函数</h2><ol><li><p>push（）</p></li><li><p>front（）、back（）</p><p>以上函数在上面示例可以看到简单用法</p></li><li><p>pop（）</p><p>pop（）函数令队首元素出队，时间复杂度是O（1）</p></li><li><p>empty（）</p><p>检查queue容器内是否为空，若为空返回true，否则返回false</p></li><li><p>size（）</p><p>返回queue容器内的元素个数。</p></li></ol><hr><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>priority_queue又称为优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是优先级别最高的元素。当然这里的优先级则是规定出来的。</p><h2 id="priority-queue容器的定义"><a href="#priority-queue容器的定义" class="headerlink" title="priority_queue容器的定义"></a>priority_queue容器的定义</h2><p>定义方式和queue容器的定义方式相同</p><h2 id="priority-queue容器内元素的访问"><a href="#priority-queue容器内元素的访问" class="headerlink" title="priority_queue容器内元素的访问"></a>priority_queue容器内元素的访问</h2><p>和queue容器不同的是，priority_queue容器并没有front（）函数和back（）函数，只能通过top（）函数来访问其堆顶元素（即优先级别最高的元素）</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main (){    priority_queue&lt;int&gt;pq;    for(int i=0;i&lt;5;i++)    pq.push(i*2);    for(;;)    {        if(pq.empty())break;        cout&lt;&lt;pq.top()&lt;&lt;" ";        pq.pop();    }    cout&lt;&lt;endl; //输出： 8 6 4 2 0    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在未涉及优先级时，用法是和queue容器大同小异的。</p><h2 id="priority-queue容器的常用函数"><a href="#priority-queue容器的常用函数" class="headerlink" title="priority_queue容器的常用函数"></a>priority_queue容器的常用函数</h2><ol><li><p>push（）</p></li><li><p>top（）</p></li><li><p>pop（）</p></li><li><p>empty（）</p></li><li><p>size（）</p><p>以上函数都可以在上面的示例当中看到简单应用。</p></li></ol><h2 id="priority-queue内元素的优先级的设置"><a href="#priority-queue内元素的优先级的设置" class="headerlink" title="priority_queue内元素的优先级的设置"></a>priority_queue内元素的优先级的设置</h2><p>如何定义优先队列中的元素优先级是运用好优先队列的关键，下面来介绍设计首先队列元素的优先级别的方法。</p><h3 id="基本数据类型的优先级设置"><a href="#基本数据类型的优先级设置" class="headerlink" title="基本数据类型的优先级设置"></a>基本数据类型的优先级设置</h3><p>这里提及的基本数据类型包括：int、char、double，优先队列对其默认是数字越大的优先级别越高（char型则比较的是字典序），则默认写法的详细写法为：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">priority_queue&lt;int&gt; name;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; name;//以上两种写法是完全等价的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若使用char或double则将int全部改为char或double即可。</p><p>若想设置数字越小优先级别越高，将less&lt; int &gt;替换为greater&lt; int &gt;即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main (){    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;pq;    for(int i=0;i&lt;5;i++)    pq.push(i*2);    for(;;)    {        if(pq.empty())break;        cout&lt;&lt;pq.top()&lt;&lt;" ";        pq.pop();    }    cout&lt;&lt;endl; //输出0 2 4 6 8    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构体的优先级的设置"><a href="#结构体的优先级的设置" class="headerlink" title="结构体的优先级的设置"></a>结构体的优先级的设置</h3><p>引入一个小小的例子，对商品的名称及价格建立一个结构体，并且规定价格高的商品优先级别更高。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct goods{string name;int price;};//定义结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为实现优先级的规定，必须在结构体中添加比较功能。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct goods{string name;int price;    friend bool operator &lt; (goods g1, goods g2){        return g1.price &lt; g2.price    } //重载小于号“&lt;”};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;struct goods    {        int price;        string name;        friend bool operator &lt; (goods g1, goods g2)        {            return g1.price&lt;g2.price;        }    };int main (){       goods g1,g2,g3;    priority_queue&lt;goods&gt; q;    g1.name="milk";g1.price=10;    g2.name="apple";g2.price=8;    g3.name="meet";g3.price=12;    q.push(g1);    q.push(g2);    q.push(g3);    for(;;)    {        if(q.empty())break;        cout&lt;&lt;q.top().name&lt;&lt;" "&lt;&lt;q.top().price&lt;&lt;endl;        q.pop();    }    return 0;}//输出：meet 12milk 10apple 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的重载符号的作用其实和sort函数中的cmp函数相似，但是实现的效果两者是相反的（在排序中return的是“&gt;”那么就是从大到小排序），这一点需要特别注意。</p><hr><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>同样顾名思义，pair的英文翻译是：一对、一双，也即把两个元素绑在一起当作一个合成元素。可以理解为一个内部有两个元素的结构体。</p><h2 id="pair的定义"><a href="#pair的定义" class="headerlink" title="pair的定义"></a>pair的定义</h2><p>要使用pair容器首先必须添加头文件#include&lt; utility &gt;，需要注意的是，由于map容器的内部涉及到了pair，所以如果头文件中添加了#include&lt; map &gt;就可以直接使用pair容器。</p><p>对比结构体和pair：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct pair{    typename1 first;    typename2 second;}pair&lt;typename1,typename2&gt; name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pair容器内元素的访问"><a href="#pair容器内元素的访问" class="headerlink" title="pair容器内元素的访问"></a>pair容器内元素的访问</h2><p>pair容器内只存在两个元素，访问方式和结构体访问方式类似。</p><p>示例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;utility&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int main (){    pair&lt;string,int&gt;p("abc",123);    cout&lt;&lt;p.first&lt;&lt;" "&lt;&lt;p.second&lt;&lt;endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常见用法有：</strong></p><ol><li><p>比较操作数</p><p>两个pair类型数据可以直接使用==、！=、&lt;等比较大小，比较规则是先比较first，在first相同的情况下才去比较second的大小。</p></li><li><p>作为map的键值进行插入</p></li></ol><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h2 id="list容器的定义"><a href="#list容器的定义" class="headerlink" title="list容器的定义"></a>list容器的定义</h2><p>list是双向循环列表，每一个元素都知道前一个元素和后一个元素，所以和vector相比，list能够更快的插入和删除，但是随机访问却比较慢。</p><p>定义与初始化：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">list&lt;typename&gt; lis1;//创建空的listlist&lt;typename&gt; lis1(n);//创建含有n个元素的listlist&lt;typename&gt; lis1(n,val);//创建n含有n各元素且值为val的listlist&lt;typename&gt; lis1(lis2);//用lis2初始化lis1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="list的访问与常用函数"><a href="#list的访问与常用函数" class="headerlink" title="list的访问与常用函数"></a>list的访问与常用函数</h2><ol><li>assign（）函数用于赋值</li><li>begin（），end（）返回首尾元素的迭代器</li><li>front（），back（）返回首尾元素</li><li>size（）返回容器的元素个数</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() {list&lt;int&gt;lis1;list&lt;int&gt;lis2(4, 10);int num[6] = {2, 17, 4, 55, 78, 16};lis1.assign(lis2.begin(), lis2.end());list&lt;int&gt;::iterator it;for (it = lis1.begin(); it != lis1.end(); it++)cout &lt;&lt; *it &lt;&lt; " "; //输出：10 10 10 10cout &lt;&lt; endl;lis1.assign(num, num + 6);for (it = lis1.begin(); it != lis1.end(); it++)cout &lt;&lt; *it &lt;&lt; " ";//输出：2,17,4,55,78,16cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.erase（）动态删除，返回当前迭代器的下一个节点（返回迭代器）。区间删除，单个删除均可以实现。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() {list&lt;int&gt;lis;for (int i = 1; i &lt;= 8; i++)lis.push_back(i);list&lt;int&gt;::iterator it, it1, it2;for (it = lis.begin(); it != lis.end(); it++)cout &lt;&lt; *it &lt;&lt; " " ;//输出： 1 2 3 4 5 6 7 8cout &lt;&lt; endl;it1 = it2 = lis.begin();advance(it2, 6);cout &lt;&lt; *it1 &lt;&lt; " " &lt;&lt; *it2 &lt;&lt; endl; //输出 1 7it1 = lis.erase(it1);cout &lt;&lt; *it1 &lt;&lt; " " &lt;&lt; *it2 &lt;&lt; endl; //输出 2 7it2 = lis.erase(it2);cout &lt;&lt; *it1 &lt;&lt; " " &lt;&lt; *it2 &lt;&lt; endl;// 输出 2 8 it1++;it2--;lis.erase(it1, it2);//输出2 6 8for (it = lis.begin(); it != lis.end(); it++)cout &lt;&lt; *it &lt;&lt; " " ;cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6.insert（）插入元素 单个元素以及区间插入均可实现 特别注意：返回的迭代器是原来的位置，插入的坐标迭代器指向的元素不变。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() {list&lt;int&gt;lis;for (int i = 1; i &lt;= 6; i++)lis.push_back(i);list&lt;int&gt;::iterator it = lis.begin(), it1;it1 = lis.insert(it, 10);cout &lt;&lt; *it &lt;&lt; endl &lt;&lt; *it1 &lt;&lt; endl;//it指向1 it1指向10return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7.splice（）把链表中的元素从一个移到另一个链表中（可以理解为剪切函数）函数无返回值</p><p>常见有三种用法，代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() {list&lt;int&gt;lis1{1, 2, 3, 4, 5};list&lt;int&gt;lis2{11, 22, 33, 44, 55};//用法一auto it = lis1.begin();advance(it, 3);lis1.splice(it, lis2);for (it = lis1.begin(); it != lis1.end(); it++)cout &lt;&lt; *it &lt;&lt; " ";cout &lt;&lt; endl;if (lis2.empty())cout &lt;&lt; "lis2 is empty" &lt;&lt; endl;/*注意两点：1.插入的位置（在迭代器指向的位置之前插入lis2）2.lis中的元素被转移后容器清空了时间复杂度常数级别*///用法二cout &lt;&lt; endl &lt;&lt; endl;it = lis1.begin();lis2.splice(lis2.begin(), lis1, it);for (it = lis1.begin(); it != lis1.end(); it++)cout &lt;&lt; *it &lt;&lt; " ";cout &lt;&lt; endl;for (it = lis2.begin(); it != lis2.end(); it++)cout &lt;&lt; *it &lt;&lt; " ";cout &lt;&lt; endl;/*同样注意用法一的那两点时间复杂度常数级别*///用法三cout &lt;&lt; endl &lt;&lt; endl;it = lis1.begin();advance(it, 3); // it-&gt;22lis2.splice(lis2.end(), lis1, it, lis1.end());for (it = lis1.begin(); it != lis1.end(); it++)cout &lt;&lt; *it &lt;&lt; " ";cout &lt;&lt; endl;for (it = lis2.begin(); it != lis2.end(); it++)cout &lt;&lt; *it &lt;&lt; " ";cout &lt;&lt; endl;/*注意：1.区间插入 左闭右开2.删除原有元素3.插入的位置时间复杂度线性级别*/return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2022/03/09/bR1bOU.png" alt="运行结果"></p><p>8.merge（）合并两个有序的list，合并后仍然有序。（默认是递增的）</p><p>9.reverse（)倒转list</p><hr><p><strong>END</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://heekaai.github.io/categories/C/"/>
    
    <category term="基础" scheme="https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="STL" scheme="https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"/>
    
    
    <category term="C++" scheme="https://heekaai.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://heekaai.github.io/tags/STL/"/>
    
    <category term="大一" scheme="https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"/>
    
    <category term="假期" scheme="https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>C语言期末复习笔记</title>
    <link href="https://heekaai.github.io/posts/1.html"/>
    <id>https://heekaai.github.io/posts/1.html</id>
    <published>2022-01-06T15:24:12.000Z</published>
    <updated>2022-01-10T06:24:58.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        临近期末考试（C语言程序设计），本人也是从暑假（7月份）开始接触的C语言，可以说是一只纯正的小白，为了更好、更有效率的备考，这篇博客也就由此诞生了。</p><p>​        顺序没啥讲究，完全是想到了什么就写出来了。很多算法优化空间还有很大。</p><h1 id="动态规划初步"><a href="#动态规划初步" class="headerlink" title="动态规划初步"></a>动态规划初步</h1><p>​    动态规划其实我感觉也可以叫作记忆化的递归优化，顾名思义，就是一种把递归可能会产生的重复运算记录下来，以空间换时间（当然空间复杂度的代价也是可以降到最小的，比如说滚动数组来实现）。</p><h2 id="DP的组成部分"><a href="#DP的组成部分" class="headerlink" title="DP的组成部分"></a>DP的组成部分</h2><p>​    几乎每一道可以用动态规划来解决的题目，设计算法的时候都可以被拆解为以下的几步：</p><ol><li><strong>确定状态（定海神针的作用）</strong><ul><li>最后一步</li><li>子问题  （由最后一步将问题分解，即解决子问题+最后一步）</li></ul></li><li><strong>确定状态转移方程</strong><ul><li>子问题定下来，状态转移就是子问题的一般化过程</li></ul></li><li><strong>初始化与边界</strong></li><li><strong>计算顺序</strong></li></ol><p>这四步听起来好像不太好理解，但是动态规划的核心就在这。通过题目应该可以更好的思考和理解动态规划的组成部分。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="坐标型DP"><a href="#坐标型DP" class="headerlink" title="坐标型DP"></a>坐标型DP</h3><p>题目描述：</p><p>&gt;<br>&gt;</p><blockquote><p>如图，A 点有一个过河卒，需要走到目标 B 点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如上图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图 C 点上的马可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。<img src="https://uploadfiles.nowcoder.com/images/20180619/305282_1529381964806_2F9E346473965B15535395B11161C11E" alt="img"></p><p>棋盘用坐标表示，A 点（0,0）、B 点（n,m）(n,m 为不超过 20 的整数，并由键盘输入)，同样马的位置坐标是需要给出的（约定: C&lt;&gt;A，同时C&lt;&gt;B）。现在要求你计算出卒从 A 点能够到达 B 点的路径的条数。</p><p>输入描述：</p><blockquote><p>输入B点的坐标（n,m）以及对方马的坐标（X,Y） (不用判错)</p></blockquote><p>输出描述：</p><blockquote><p>输出一个整数表示路径的条数。</p></blockquote><p>样例输入：</p><blockquote><p>6 6 3 2</p></blockquote><p>样例输出：</p><blockquote><p>17</p></blockquote></blockquote><p>原题链接：<a href="https://ac.nowcoder.com/acm/contest/24213/1008">Nowcoder-过河卒</a></p><p>题目分析：</p><blockquote><p>参照上面的DP组成部分，一步一步来：</p><ul><li>最后一步：最后一定会到达（n，m）的位置</li><li>子问题：在没有马控制的前提下，一定是由（n-1，m）或者（n，m-1）过来</li><li>状态转移方程：dp[i] [j]=dp[i-1] [j]+dp[i] [j-1]</li><li>初始化与边界：首先马的领地是不能到的，直接记为0；然后就是第一行和第一列都是1；在初始化第一行第一列的时候，遇到马就直接break，因为后面的都到不了了；</li></ul></blockquote><p>AC代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;long long dp[25][25];bool judge[25][25];//判断是否为马的领地，布尔数组合适int main (){    memset(judge,true,sizeof(judge));    int n,m,x,y;    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;x,&amp;y);    judge[x][y]=0;    judge[x-2][y-1]=judge[x-2][y+1]=judge[x-1][y-2]=judge[x-1][y+2]=0;    judge[x+2][y-1]=judge[x+2][y+1]=judge[x+1][y-2]=judge[x+1][y+2]=0;    for(int i=0;i&lt;=m;i++)    {        if(judge[0][i])dp[0][i]=1;        else break;    }    for(int j=0;j&lt;=n;j++)    {        if(judge[j][0])dp[j][0]=1;        else break;    }    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=m;j++)        {            if(judge[i][j])dp[i][j]=dp[i-1][j]+dp[i][j-1];        }    }    printf("%lld\n",dp[n][m]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列DP"><a href="#序列DP" class="headerlink" title="序列DP"></a>序列DP</h3><p>原题链接：<a href="http://202.197.224.59/exam/index.php/problem/exam_read/id/1378/exam_id/355">XTUOJBlocks</a></p><p>题目描述：</p><blockquote><p>给你一个n块积木，每个积木块都是立方体，现在把它们排列一排，成m列，要求每列上至少有1个积木，且从左到右，每列的积木数量呈严格单调下降。</p></blockquote><p>​        题意即求n等于m个不同的数相加的方案数</p><ul><li><p>最后一步：m个数不同，则一定有最大的数，记为k。</p></li><li><p>子问题：则求解n-k等于m-1个不同的数相加的方案数。</p></li><li><p>状态转移方程：</p><script type="math/tex; mode=display">dp(i,j,k)=\sum_{t<k}dp(i-k,j-1,t)</script></li><li><p>初始化与边界：m=1时方案数为1</p></li></ul><p>代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int dp[101][11][101];int main(){    dp[1][1][1]=1;    for(int i=2;i&lt;101;i++)    {        for(int j=1;j&lt;11;j++)        {            for(int k=1;k&lt;=i;k++)            {                if(j==1&amp;&amp;k==i)                {                    dp[i][j][k]=1;                    continue;                }                for(int r=1;r&lt;k;r++)                {                    dp[i][j][k]+=dp[i-k][j-1][r];                }            }        }    }    int T,n,m;    scanf("%d",&amp;T);    while(T--)    {        scanf("%d%d",&amp;n,&amp;m);        int ans=0;        for(int i=1;i&lt;=n;i++)        {            ans+=dp[n][m][i];        }        printf("%d\n",ans);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变式：<a href="http://202.197.224.59/exam/index.php/problem/exam_read/id/1398/exam_id/356">XTUOJ积木Ⅱ</a></p><p>题目描述：</p><blockquote><p>n个积木，分成m垛，这些积木垛排成一行，使得所有垛的积木块数不相同，且呈“山“字形（积木数先单调上升，再单调下降）。现在已知n,m,请求方案数。</p></blockquote><p>​        有上面这题的基础，这题也就不难了</p><p>​        大体思路：有了n个数等于m个不同的数相加的方案数，对于这个单调的序列，除了最大的数以外，每个数都有两个选择 留在左边 或者放到右边 两个选择。但是不能全留也不能全走。</p><script type="math/tex; mode=display">f(i,j)=(2^{j-1}-2)*\sum_{k=1}^idp(i,j,k)</script><p>AC代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int dp[101][11][101];int mi(int x){    int res=1;    for(int i=0;i&lt;x;i++)    res*=2;    return res;}int main(){    dp[1][1][1]=1;    for(int i=2;i&lt;101;i++)    {        for(int j=1;j&lt;11;j++)        {            for(int k=1;k&lt;=i;k++)            {                if(j==1&amp;&amp;k==i)                {                    dp[i][j][k]=1;                    continue;                }                for(int r=1;r&lt;k;r++)                {                    dp[i][j][k]+=dp[i-k][j-1][r];                }            }        }    }    int T,n,m;    scanf("%d",&amp;T);    while(T--)    {        scanf("%d%d",&amp;n,&amp;m);        int ans=0;        for(int i=1;i&lt;=n;i++)        {            ans+=dp[n][m][i];        }        ans*=(mi(m-1)-2);        printf("%d\n",ans);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然动态规划内容远比这多，只是在这里给大家提供一种思想，遇到动态规划，往这四个组成部分上面去靠去思考准没错。</p><p>​        动态规划敬请期待后续文章。</p><h1 id="排序篇"><a href="#排序篇" class="headerlink" title="排序篇"></a>排序篇</h1><h2 id="选择、插入排序"><a href="#选择、插入排序" class="headerlink" title="选择、插入排序"></a>选择、插入排序</h2><p>​        冒泡、选择、插入排序是比较基础、简单的一类排序方法，相对的，它们的执行效率也会相对比较低。在不做优化的情况下，时间复杂度会达到 O（n^2） 的级别，这在很多情况下都是难以接受的。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>​        选择排序（Selection-sort）是一种简单直观的排序算法。</p><p>​        首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。每一次从无序组的数据元素中选出最小的一个元素，存放在无序组的起始位置，无需组的元素减少，有序组的元素增加，直到全部待排序的数据元素排完。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;//选择排序void selectSort(int arry[], int len){       int i;        int j;        for ( i = 0; i &lt; len-1; i++)        {                int min = i;//假设第一个元素是最小的                for (j = i + 1; j &lt; len; j++)                {                        if (arry[j] &lt; arry[min])                        {                                min = j;//保存最小元素的下标                        }                }                //交换                int temp = arry[min];                arry[min] = arry[i];                arry[i] = temp;        }}//输出void print(int arry[], int len){        for (int i = 0; i &lt; len; i++)        {                printf("%d ", arry[i]);        }}int main(){        int arry[10]={15,36,26,27,24,46,44,29,52,48};        selectSort(arry,10);        print(arry,10);        printf("\n");        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>​        插入排序是最简单常用的方法，将数组分为两部分，排好序的数列，以及未排序的数列，将未排序的数列中的元素 与排好序的数列进行比较，然后将该元素插入到已排序列的合适位置中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;//插入排序void insertSort(int arry[], int len){        int i;        int temp;//保存要插入的元素        int j;//从当前要要比较插入的元素的前面一个开始        for ( i = 1; i &lt; len; i++)//第一个元素视为有序,把后面的元素一个一个的插入到前面        {                temp = arry[i];                j = i - 1;                while (j &gt;= 0&amp;&amp;arry[j]&gt;temp)                {                        arry[j + 1] = arry[j];//前面的元素往后面移动                        j--;                }                arry[j + 1] = temp;//把要插入的元素,插入进对应的位置        }}//输出void print(int arry[], int len){        for (int i = 0; i &lt; len; i++)        {                printf("%d ", arry[i]);        }}int main(){        int arry[10]={3,44,38,5,47,15,36,26,27,2};        insertSort(arry,10);        print(arry,10);        printf("\n");        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>​        quicksort快速排序，qsort()是c语言的库函数，在头文件<stdlib.h>中，基于二分的思想，所以执行效率非常的优秀，务必掌握。</stdlib.h></p><p>​        qsort()函数的四个参数：</p><ul><li><p>数组名（待排元素的首地址）</p></li><li><p>待排元素的个数</p></li><li><p>数据类型所占字节大小</p></li><li><p>cmp函数  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int cmp(const void *a, const void *b) //格式是固定不变的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="int-型"><a href="#int-型" class="headerlink" title="int 型"></a>int 型</h3><p>模板：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int cmp(const void *a,const void *b){    int *pa=(int *)a; //强制类型转换    int *pb=(int *)b;    return *pa-*pb;}int main (){    int a[5]={5,3,45,78,9};    qsort(a,5,sizeof(int),cmp); //传参形式    for(int i=0;i&lt;5;i++)    printf("%d ",a[i]);    printf("\n");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        若想要实现降序，只需将cmp函数的返回值改为相反数即可。</p><p>​        相应的，char型字符数组，要实现排序，只需要改动cmp函数里的强制类型转换部分。</p><h3 id="二维int型"><a href="#二维int型" class="headerlink" title="二维int型"></a>二维int型</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; #define N 4 int cmp(const void *a,const void *b){    int *pa=(int *)a;    int *pb=(int *)b;    int i=0;    for(;i&lt;N&amp;&amp;*pa==*pb;i++,pa++,pb++);    if(i==N) return 0;    else return *pa-*pb;}void prt(int (*a)[N],int n){    int i,j;    for(i=0;i&lt;n;i++){        for(j=0;j&lt;N;j++) printf("%d ",a[i][j]);        printf("\n");    }    printf("\n");} int main(){    int a[5][N]={{1,7,3,4},{1,5,4,3},{2,5,3,7},{2,5,3,8},{1,7,4,3}};    prt(a,5);    qsort(a,5,sizeof(a[0]),cmp);    prt(a,5);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>​        利用<string.h>头文件里现成的比较函数strcmp（）函数即可。</string.h></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; int less(const void *a,const void *b){    char *pa,*pb;    pa = (char *)a;    pb = (char *)b;    return strcmp(pa,pb);}void prt(char (*a)[20],int n){    int i;    for(i=0;i&lt;n;i++) puts(a[i]);    printf("\n");}int main(){    char a[10][20]={"Hello","Hell","Her","He","His","Hers","Helm","Heat","Heal","Heap"};    prt(a,10);    qsort(a,10,sizeof(a[0]),less);    prt(a,10);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h1><h2 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h2><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>​        一般用 gcd（a,b） 来表示 a 和 b 的最大公约数，而求解最大公约数的方法通常是欧几里得算法（即辗转相除法）</p><p>​        欧几里得算法基于如下定理：</p><script type="math/tex; mode=display">gcd(a,b)=gcd(b,amodb)</script><p>​    证明过程暂且省略，并且容易得知gcd（a , 0）= 0 。所以很明显是一个是一个递归，递归式和边界都已得到，则可以写出代码的模板：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int gcd(int a,int b){    if(b==0) return a;    else return gcd(b,a%b);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    当然，引进中间变量的写法也是可以的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int gcd(int a,int b){    int t;    while (b!=0)    {        t=a%b;        a=b;        b=t;    }    return a;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        选择任意一种方便自己记忆的写法即可。</p><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>​    最小公倍数在最大公约数的基础上进行，一般用 lcm（a , b）表示 a 和 b 的最小公倍数。</p><p>​    若将 a 和 b 的最大公约数记作 c 的话，最小公倍数自然就是 a<em>b / d ，但是这样写a </em> b在计算的过程中容易溢出，更好的写法是 （a/d）*b 。</p><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>​        素数的定义都熟，也就不再赘述了。特别注意，<strong>1既不是素数也不是合数</strong>。</p><p>​        应对期末考试里面有关素数的题目，打素数表显然是一种最好的方法，目前还没有出现过问题，属于是百试不爽了。</p><p>​        打素数表，首推的是筛法求解，这样进一步把时间复杂度降低了。一般就选埃氏筛和欧拉筛（时间复杂度都可以达到线性）。但是我用欧拉筛比较多一点，所以这里就放欧拉筛的代码模板了。</p><p>​        还要表明的一点就是，因为是线性打表，所以有空间上的限制，一般到1e7都是不会出问题的，更大的话编译就会报错了。</p><p>​    模板如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define N 1000007bool num[N]; //在&lt;stdbool.h&gt;里int  prime[N];int main (){    memset(num,true,sizeof(num)); //在&lt;string.h&gt;里    num[1]=false;    int cnt=0;    for(int i=2;i&lt;N;i++)    {        if(num[i]==true)prime[cnt++]=i;        for(int j=0;j&lt;cnt&amp;&amp;prime[j]*i&lt;N;j++)        {            num[i*prime[j]]=false;            if(i%prime[j]==0)break;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于上面模板，prime里面所有数都是有序素数，num下标用以判断是否为素数。还要一点需要注意，N开的时候至少要比n大1。</p><h2 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h2><blockquote><p><strong>唯一分解定理：</strong></p><p>​        <em>每个大于1的自然数</em>，要么本身就是质数，要么可以写为2个或以上的质数的积，而且这些质因子从小到大排序，写法仅有一种方式。</p></blockquote><p>​        个人感觉这个知识点也是期末考试里比较常见的考点。</p><p>​        由上面唯一分解定理不难看出，在做质因子分解有关题目时，还得借助上面提到的素数部分内容，必须提前打好素数表。</p><p>​        Tips：</p><p>&gt;<br>&gt;</p><blockquote><p>​        对于一个正整数 n 来说，如果它存在 1 和本身以外的因子，那么是一定在sqrt（n）的左侧和右侧成对出现（这就是判断 n 是否为素数时只要从1 - sqrt（n）的原因）。</p><p>​        把这个结论用在质因子分解上面：对于正整数 n（n≥2）言,至多只存在一个大于sqrt（n）的质因子，其余的质因子全部小于等于sqrt（n）。</p></blockquote><p>​        所以质因子分解的核心思路就出来了：</p><ul><li><p>​    枚举 1 ~ sqrt（n）的所有质数</p></li><li><p>​    记质因子为p，考虑到有多个相同的质因子，所以重复直至无法整除。</p></li><li>​    如果上述步骤结束后， n 仍然大于 1 ，说明 n 有且只有一个大于sqrt（n）的质因子，如果  n 是素数，则就是 n 本身。</li></ul><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="http://202.197.224.59/exam/index.php/problem/exam_read/id/1396/exam_id/356#_2">XTUOJ1396</a></p><p>题目描述：</p><p>&gt;<br>&gt;</p><blockquote><p>根据质因子唯一分解定理可知</p><script type="math/tex; mode=display">n=\prod_{i=1}^mpi^{ki}</script><p>其中 pi 为素数。</p><script type="math/tex; mode=display">定义g(n)=\sum_{i=1}^{m}ki,求\sum_{i=a}^bg(i)</script></blockquote><p>输入与输出：</p><p>&gt;<br>&gt;</p><blockquote><p>输入：第一行是一个整数T（1≤T≤10000），表示样例的个数。 以后每行两个整数a,b（1≤a≤b≤10^6）。</p><p>输出：每行输出一个样例的结果。</p></blockquote><p>样例输入与输出</p><p>&gt;<br>&gt;</p><blockquote><p>输入：</p><p>2</p><p>1 2</p><p>1 1000000</p><p>输出：</p><p>1</p><p>3626619</p></blockquote><p>​        感觉这题就是考察上面提到的东西，区间的那一段，就用前缀和解决即可。直接看代码吧，注释部分解释的很详细。</p><p>AC代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdbool.h&gt;#define N 1000007 bool num[N];int prime[N];int fact[N];int sum[N];void X(){    // 打素数表，其实开到sqrt(n)即可，但是过了就懒得优化了    memset(num,true,sizeof(num));    int cnt=0;    for(int i=2;i&lt;N;i++)    {        if(num[i]==true)        prime[cnt++]=i;        for(int j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;N;j++)        {            num[i*prime[j]]=false;            if(i%prime[j]==0)break;        }    }    // 找质因子个数    int count=0;    for(int i=2;i&lt;N;i++)    {        count=0; //count作用是记录每个质因子个数，进入循环前记得清0        int k=i;        for(int j=0;j&lt;cnt&amp;&amp;prime[j]*prime[j]&lt;=k;j++)        {            if(k%prime[j]==0)            {                while(k%prime[j]==0)                {                    k/=prime[j];                    count++;                }            }        }        if(k!=1)count++;  //还剩下一个质因子        fact[i]=count; //用fact存放每个整数i的质因子个数，即g(i);    }    for(int i=2;i&lt;N;i++)   sum[i]=sum[i-1]+fact[i]; //题目要求区间的和，显然前缀和比较合适}int main (){    X();    int T,a,b;    scanf("%d",&amp;T);    while(T--)    {        scanf("%d%d",&amp;a,&amp;b);        printf("%d\n",(sum[b]-sum[a-1])); //前缀和 a-1 不要弄错    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="http://202.197.224.59/exam/index.php/problem/exam_read/id/1377/exam_id/355">XTUOJ1377</a> 同一个考点，解法非常相似。</p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>​    打表是我最喜欢的方法，快并且简单！</p><p>​    数学原理就是杨辉三角呗</p><p>模板代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">long long num[65][65]; //一定记得开long long不然会爆void F(){    int i,j,k;    for(i=0;i&lt;65;i++)    {        num[i][i]=1;        num[i][0]=1;    }    for(i=1;i&lt;65;i++)        for(j=1;j&lt;i;j++)            num[i][j]=num[i-1][j]+num[i-1][j-1];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>​        数学问题当然还有很多，比如说分数的四则运算（可以转化成假分数的形式，加上最大公约数的化简基本上就能过），还有大整数的四则运算（感觉期末考试这个好像没考过，但是我也有一点点心得，以后可以总结一下，在这里就先不写出来了）</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="简单贪心"><a href="#简单贪心" class="headerlink" title="简单贪心"></a>简单贪心</h2><blockquote><p>​        贪心算法是求解一类最优化问题的方法，总是做出在当前看来是最好的选择（局部最优）。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。（“活在当下，及时享乐”）贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p></blockquote><p>​        解题的一般步骤是：<br>​        1.建立数学模型来描述问题；<br>​        2.把求解的问题分成若干个子问题；<br>​        3.对每一子问题求解，得到子问题的局部最优解；<br>​        4.把子问题的局部最优解合成原来问题的一个解。</p><p>​        看到子问题是不是又想到了动态规划。贪心和动态规划都要求原问题必须拥有<strong>最优子结构</strong>。二者的区别在于，贪心法采用的计算方式类似于“自顶向下”，但是并不等待子问题求解完后<br>再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不<br>去求解了，<strong>直接抛弃</strong>。也就是说，它总是只在上一步选择的基础上继续选择，因此整个过程<br>以一种单链的流水方式进行，<em>显然这种所谓 “最优选择” 的正确性需要用归纳法证明</em>。（而证明过程往往会比贪心本身复杂）而动态规划不管是采用自底向上还是自顶向下的计算方式，都是从边界开始向上得到目标问题的解。也就是说，它总是会考虑所有子问题，并选择继承能得到最优结果的那个，对暂时没被继承的子问题，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。所以贪心是一种壮士断腕的决策，只要进行了选择，就不后悔；动态规划则要看哪个选择笑到了最后，暂时的领先说明不了什么。</p><p>​        贪心算法设计时往往无需加以证明，自己认为无法举出反例就可以放心大胆的去设计。</p><p>​        例题：</p><p>原题链接：<a href="https://ac.nowcoder.com/acm/contest/20960/1036">Nowcoder字典序最大的子序列</a></p><p>题目描述：</p><blockquote><p>给定字符串s（只包含小写字母），请求出最大子序列。</p></blockquote><p>输入与输出：</p><blockquote><p>输入一行一个字符串 s ，且1 &lt;= |s| &lt;= 100,000</p><p>输出字典序最大的子序列</p></blockquote><p>样例：</p><blockquote><p>样例1：</p><p>输入：</p><p>ababba</p><p>输出：</p><p>bbba</p><p>样例2：</p><p>输入：</p><p>abbcbccacbbcbaaba</p><p>输出：</p><p>cccccbba</p></blockquote><p>​        这题很简单，大家可以感受一下贪心。字典序最大是不是第一个字母的字典序越大就越好，所以就把当前序列中最大的字典序找出来即可。及时缩短字符串长度。</p><p>AC代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main (){    char s[100007];    scanf("%s",s);    int len=strlen(s);    char max='a'-1;    int cnt[128];    memset(cnt,0,sizeof(cnt));    for(int i=0;i&lt;len;i++)    {        cnt[s[i]]++;        if(max&lt;s[i])max=s[i];    }    for(int i=0;i&lt;len;i++)    {        if(max==s[i])        printf("%c",max);        cnt[s[i]]--;        if(cnt[max]==0)        {            for(;max&gt;='a';max--)            {                if(cnt[max])break;            }        }    }    printf("\n");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h2><p>​        贪心算法思路都是相同的，区间贪心自然不例外，保证当下最优即可。</p><p>​        区间贪心即对于区间有交集的问题，如何求解最多有几个区间能够互不相交，或者如何用尽量少的区间表示这些区间。</p><p>​        也是拿一道例题说明：</p><p>原题链接：<a href="https://ac.nowcoder.com/acm/contest/20960/1018">Nowcoder值周</a></p><p>题目描述：</p><blockquote><p>JC内长度为L的马路上有一些值周同学，每两个相邻的同学之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0,1,2,…L，都有一个值周同学。 由于水宝宝有用一些区间来和ssy搞事情，所以为了避免这种事走漏风声，水宝宝要踹走一些区域的人。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的人（包括区域端点处的两个人）赶走。你的任务是计算将这些人都赶走后，马路上还有多少个人。</p></blockquote><p>输入与输出：</p><blockquote><p>输入：</p><p>第一行有2个整数L和M，L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。 接下来的M行每行包含2个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标</p><p>输出：</p><p>1个整数，表示马路上剩余的人的数目。</p></blockquote><p>样例：</p><blockquote><p>样例1：</p><p>输入：</p><p>500 3</p><p>150 300</p><p>100 200</p><p>470 471</p><p>输出：</p><p>298</p><p>样例数据说明:</p><blockquote><p>对于所有的数据，1≤L≤100000000</p><p>对于10%的数据，1&lt;=M&lt;=100</p><p>对于20%的数据，1&lt;=M&lt;=1000</p><p>对于50%的数据，1&lt;=M&lt;=100000</p><p>对于100%的数据，1&lt;=M&lt;=1000000</p></blockquote></blockquote><p>​        </p><p>放上AC代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#define N 2int num[1000007][2];int cmp(const void *a,const void *b){    int *pa=(int *)a;    int *pb=(int *)b;    int i=0;    for(;i&lt;N&amp;&amp;*pa==*pb;i++,pa++,pb++);    if(i==N) return 0;    else return *pa-*pb;}int main (){    int L,M;    scanf("%d%d",&amp;L,&amp;M);    int ans=L+1;    for(int i=0;i&lt;M;i++)    scanf("%d%d",&amp;num[i][0],&amp;num[i][1]);    qsort(num,M,sizeof(num[0]),cmp);    int l=num[0][0],r=num[0][1];    for(int i=1;i&lt;M;i++)    {        if(num[i][0]&lt;=r)  //已经是有序的序列所以只会有三种情况        {            if(num[i][1]&gt;r)r=num[i][1]; // 两端被包括在内的情况被这个if排除        }        else{            ans-=(r-l+1); //两端也被去掉了+1不能漏            l=num[i][0];            r=num[i][1];        }    }    ans-=(r-l+1); //最后一组的区间没有减    printf("%d\n",ans);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这题要用到之前提到的快速排序。区间贪心部分的解释已经在代码注释中给出。</p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>​        二分查找是基于有序序列的查找算法，递增和递减原理上并无区别，代码上稍微改动即可，所以下面都一严格递增序列为例。</p><p>​        算法原理：</p><p>&gt;<br>&gt;</p><blockquote><p>[ left , right ]一开始定为整个序列的左端和右端区间，每次判断中间位置与x的大小关系，则会有以下几种情况出现：</p><p>其中 mid = （left + right） / 2 ，序列记为num[ ] </p><ul><li>若 num[mid]==x 跳出</li><li>若 num[mid]&gt;x，则x在mid左边，right 更新为 mid-1</li><li>若 num[mid]&lt;x，则x在mid右边，left 更新为 mid+1</li></ul></blockquote><p>​        原理很好理解，代码也不难实现，所以这里就不放模板代码了，因为每次题目都不会考察的这么直白，不会直接考查找某某某元素，而是会绕着考，所以核心是要理解二分的思想，运用二分的思想从而达到降低时间复杂度的目的，因为二分每一步都能去除一般的区间，所以时间复杂度是 O (logn) 级别的，非常的高效！</p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>先放上原题链接：<a href="https://ac.nowcoder.com/acm/contest/22353/F">Nowcoder-华华给月月准备礼物</a></p><p>题目描述：</p><blockquote><p>二月中旬虐狗节前夕，华华决定给月月准备一份礼物。为了搭建礼物的底座，华华需要若干根同样长的木棍。华华手头上有一些长度参差不齐的木棍，他想将每根都裁剪成若干段自己想要的长度，并丢掉多余的部分。因为华华的手很巧，所以他的裁剪过程不会有任何的失误。也就是说，对于一根长度为N的木棍，华华可以精准的将它们裁剪为若干段木棍，使它们的长度之和为N。<br>华华不知道裁剪成多长比较好，所以干脆越长越好。不过由于华华有点强迫症，所以他希望长度为非负整数。保证所有木棍的原长也是非负整数。那么请问华华最终得到的每根木棍多长呢？</p></blockquote><p>输入：</p><blockquote><p>第一行两个正整数N、K，表示木棍原本的根数和华华希望得到的木棍根数。<br>第二行N个正整数 Li 表示每根木棍的初始长度。</p><p>数据备注：</p><blockquote><p>1 ≤ N ≤ 2*1e5 ， 1 ≤ Li ≤ 1e9 ， 1 ≤ K ≤ 1e9</p></blockquote><p>输出一行一个非负整数，表示华华最终得到的n根木棍的每根最大长度。</p></blockquote><p>样例</p><blockquote><p>示例1：</p><blockquote><p>输入：</p><p>5 10</p><p>4 4 4 5 3</p></blockquote><p>&gt;<br>&gt;</p><blockquote><p>输出：</p><p>1</p></blockquote><p>示例2：</p><blockquote><p>输入：</p><p>5 3</p><p>1 2 3 4 5</p><p>输出：</p><p>3</p></blockquote></blockquote><p>​        题目分析：</p><p>​        是不是咋一看很难和二分法联系上去，但是你仔细思考，还是很容易发现其和二分的联系的。很显然，（记每根木棍的长度为L，这样裁剪能够得到的木棍根数为K）随着 L 增大，那么可以得到的根数 K 会变小。从这个角度出发就可以想到本题可以通过二分L，判断 K 和目标值的大小关系，及时调整区间的左右端点值。</p><p>​        附上代码可能会更好理解。</p><p>​        AC代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int N,K,L[200007]; //全局变量可以不需要重复传参int C(int x)  //计算根数的函数{    int ans=0;    for(int i=0;i&lt;N;i++)        ans+=L[i]/x;    return ans;}int main (){    scanf("%d%d",&amp;N,&amp;K);    int l=1,r=0;    for(int i=0;i&lt;N;i++)    {        scanf("%d",&amp;L[i]);        if(L[i]&gt;r)r=L[i];    }    r++; //这个细节要注意，最大的L是可以重复的，嫌麻烦可以直接把r开到1e9    while(l&lt;r) //这是个小小的转换    {        int mid=(l+r)/2;        int k=C(mid);        if(k&lt;K) r=mid;        else l=mid+1;    }    printf("%d\n",l-1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        解题的大体思路代码中用注释解释清楚了，只是最后的while循环那里有个小小的转换，题意满足要求最大的长度，不如转化成第一个不满足条件的长度，在用这个长度-1即可得到答案，这样的转换可以让代码变得更加简洁。</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>​    快速幂其实就是二分的一个应用，就是一个小技巧吧，见过的就自然会用。基于二分的思想，因此也常称为二分幂。</p><p>题目链接：<a href="https://www.luogu.com.cn/problem/P1226">快速幂||取余运算 </a></p><p>大体思路：</p><p>&gt;<br>&gt;</p><blockquote><ul><li><p>如果b是奇数</p><script type="math/tex; mode=display">a^b=a*a^{b-1}</script></li><li><p>如果b是偶数</p><script type="math/tex; mode=display">a^b=a^{b/2}*a^{b/2}</script></li></ul></blockquote><p>​    经过一定次数的转换，b可以变到0。很明显是一种递归的思想，时间复杂度则是O（logb）</p><p>代码模板：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">long long fastPower(long long base, long long power,long long mod) {    long long result = 1;    while (power &gt; 0) {        if (power % 2 == 1) {            result = result * base % mod;        }        power = power / 2;        base = (base * base) % mod;    }    return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    当然快速幂也有一种迭代的写法，但是迭代和递归的写法在效率上区别不大，所以不在这里过多阐述。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>​        都是一些比较简单的知识和入门级别算法，大佬不喜勿喷。</p><p>​        感谢你能够看到这篇文章的最后！！这也算是个人的第一篇博客了，希望能够有所收获。文章里发现任何问题，一定记得联系我指出噢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C语言" scheme="https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="算法笔记" scheme="https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="大一" scheme="https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"/>
    
    <category term="C" scheme="https://heekaai.github.io/tags/C/"/>
    
    <category term="学习" scheme="https://heekaai.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="基础算法" scheme="https://heekaai.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>博客的诞生</title>
    <link href="https://heekaai.github.io/posts/3c47c717.html"/>
    <id>https://heekaai.github.io/posts/3c47c717.html</id>
    <published>2022-01-03T14:35:02.000Z</published>
    <updated>2022-01-19T02:20:57.023Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>相遇就是缘！</strong></p><h1 id="为什么要搭建博客？"><a href="#为什么要搭建博客？" class="headerlink" title="为什么要搭建博客？"></a>为什么要搭建博客？</h1><p>纯属自己的个人兴趣吧！记录自己最近都干了什么，学到了什么，或许会有一些成就感吧！拥有一个自己的博客写一写自己感兴趣或者正在研究的事或物，不是一件很有意义的事情嘛！</p><h1 id="展望博客"><a href="#展望博客" class="headerlink" title="展望博客"></a>展望博客</h1><p>我会整理一些自己目前在学的东西，一方面能够让自己复习，一方面也能记录一下学习的过程，也希望能够让有兴趣的小伙伴能够看到，也是一个共同进步的过程。</p><h1 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h1><p>我真的是一个很懒很懒的人，平时最喜欢干的事情就是睡觉。希望通过写博客来提高提高自己的学习积极性。</p><p>“人间失格”听上去真的很非主流，我自己也这么觉得。但是取名字我觉得更加麻烦，《人间失格》是太宰治的一本书，索性就直接引用过来了。</p><hr><p>最后拿《人间失格》里的一句话作结吧</p><blockquote><p>如今的我，谈不上幸福，也谈不上不幸。</p><p>一切都会过去的。</p><p>在所谓的“人世间”摸爬滚打至今，</p><p>我唯一愿意视为真理的，就只有这一句话，</p><p>一切都会过去的！</p><p>​                                  ————太宰治《人间失格》</p></blockquote><p><strong>感谢你看到了最后！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="简介" scheme="https://heekaai.github.io/categories/%E7%AE%80%E4%BB%8B/"/>
    
    
    <category term="生活" scheme="https://heekaai.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://heekaai.github.io/posts/4a17b156.html"/>
    <id>https://heekaai.github.io/posts/4a17b156.html</id>
    <published>2022-01-02T12:28:30.418Z</published>
    <updated>2022-01-02T15:36:49.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
