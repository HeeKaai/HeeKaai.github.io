{"meta":{"title":"人间失格","subtitle":"人间失格の博客","description":"本科 | 计算机科学与技术 | 算法笔记","author":"HeeKaai","url":"https://heekaai.github.io","root":"/"},"pages":[{"title":"","date":"2022-01-02T12:43:43.492Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://heekaai.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.398Z","comments":true,"path":"404.html","permalink":"https://heekaai.github.io/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/index.html","permalink":"https://heekaai.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2022-01-02T12:43:43.492Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://heekaai.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"about/index.html","permalink":"https://heekaai.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"archives/index.html","permalink":"https://heekaai.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"categories/index.html","permalink":"https://heekaai.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"census/index.html","permalink":"https://heekaai.github.io/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"friends/index.html","permalink":"https://heekaai.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"resource/index.html","permalink":"https://heekaai.github.io/resource/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T14:48:55.758Z","comments":true,"path":"contact/index.html","permalink":"https://heekaai.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 人间失格の友链信息 博客名称: 人间失格の博客 博客网址: https://heekaai.github.io 博客头像: https://s4.ax1x.com/2022/01/02/TTxWtK.jpg 博客介绍: 接受平凡，努力出众"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"tags/index.html","permalink":"https://heekaai.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/index.html","permalink":"https://heekaai.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/movies/index.html","permalink":"https://heekaai.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/tools/index.html","permalink":"https://heekaai.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/music/index.html","permalink":"https://heekaai.github.io/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://heekaai.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://heekaai.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://heekaai.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://heekaai.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"STL入门--algorithm头文件","slug":"STL入门-algorithm头文件","date":"2022-02-18T02:51:59.312Z","updated":"2022-03-02T08:36:37.022Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://heekaai.github.io/posts/3.html","excerpt":"","text":"[TOC] algorithm头文件下的常用函数前提：添加algorithm头文件 max（）、min（）和abs（）max（x，y）和min（x，y）分别返回x和y中的最大值和最小值，且参数必须是两个（可以是浮点数）。如果想要返回三个数x、y、z的最大值，可以通过max（x，max（y，z））的写法。 abs（x）返回x的绝对值。注意：x必须是整数，浮点型的绝对值请用math头文件下的fabs。 swap（）swap（x，y）用以交换x和y的值 reverse（）reverse（it1，it2）可以将数组指针在[ it1, it2 ）之间的元素或迭代器在[ it1, it2 ）范围内的元素进行反转。（左闭右开的特点）示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt;ve; int num[9]; for (int i = 0; i &lt; 6; i++) { num[i] = i; ve.push_back(i); } vector&lt;int&gt;::iterator it=ve.begin(); reverse(it + 1, it + 4); reverse(num + 1, num + 4); for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; ve[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; num[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; //输出：0 3 2 1 4 5 return 0; } next_permutation（）next_permutation（）给出一个序列在全排列中的下一个序列。 全排列是按照字典序由小至大的顺序进行排序。 并且值得注意的是其返回值，若存在下一个排序，返回值是true；若不存在最后一个排序（即当前为最后一个全排列），返回值则为false。根据这一特性，通常会使用do···while···循环来实现全排列。 下面是1-9全排列的代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main () { int num[9]; for(int i=0;i&lt;9;i++) num[i]=i+1; do{ for(int i=0;i&lt;9;i++) cout&lt;&lt;num[i]&lt;&lt;\" \"; cout&lt;&lt;endl; }while(next_permutation(num,num+9)); return 0; } fill（）fill（）函数可以将数组或容器某区间内所有元素全部赋值为同一值，用法和memset类似，但是fill（）函数的赋值可以是数据范围内的一值。 具体用法： fill(it1,it2,num)； //it可以是指针或者是迭代器 sort（）顾翻译思义，sort就是用来排序的函数，效率较高。相比于C语言中的qsort函数，sort函数用起来更加便捷，并且规避某些效率特别低的情况。 sort函数的三个参数 第一个是要排序的数组的起始地址。 第二个是结束的地址（最后一位要排序的地址）的下一个地址 比较函数 其中第三点非必填内容，若不填，则默认递增的顺序 一定特别需要注意的是：“左闭右开”第二个参数是末尾元素的下一个地址 比较函数cmp的书写cmp函数的书写就好比人为给sort（）函数制定比较规则一样，让sort（）函数按照自己的想法进行排序。 基本数据类型 基本数据类型本身就具有可比性，则默认即为增序。只需记忆递减的情形下的cmp函数。 示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; bool cmp(int a, int b) { return a &gt; b; } int main() { int num[5]{3,8,1,2,4}; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出：3 8 1 2 4 cout &lt;&lt; endl; sort(num, num + 5); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出： 1 2 3 4 8 cout &lt;&lt; endl; sort(num, num + 5, cmp); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出： 8 4 3 2 1 cout &lt;&lt; endl; return 0; } 其他数据类型同理可知。 结构体数组的排序 结构体本身并无直接可比性，所以就没有默认排序一说，都需要通过书写cmp函数来实现人为制定比较规则。 一级排序： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; struct test { int x, y; }ss[5]; bool cmp(test a, test b) { return a.x &lt; b.x;//“&lt;”从小至大 “&gt;”从大至小 } int main() { for (int i = 0; i &lt; 5; i++) { ss[i].x = rand()%17; ss[i].y = rand()%17;//随机数 } for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; ss[i].x &lt;&lt; \" \" &lt;&lt; ss[i].y &lt;&lt; endl; } cout &lt;&lt; endl; sort(ss, ss + 5, cmp); for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; ss[i].x &lt;&lt; \" \" &lt;&lt; ss[i].y &lt;&lt; endl; } return 0; } 很明显可以发现，一级排序仅仅只会排序结构体中的第一个变量，若想实现第二个变量的排序，只需改变cmp函数的写法 bool cmp(test a, test b) { if (a.x != b.x)return a.x &lt; b.x; else return a.y &gt; b.y; }//x从小到大，y从大到小的顺序 类似的可以进行扩展。 STL容器的排序 前提：STL容器中只有vector、string、deque才可以使用sort函数进行排序 用法类似于数组，牢记“左闭右开”的规则。 lower_bound（）和upper_bound（）前提：数组或容器本身是有序的 lower_bound（left，right，num）用来在容器或数组的[left，right）中查找第一个大于或等于num的元素的位置。若为数组，返回指针；若为容器，返回迭代器。 相应的，upper_bound（）函数的作用是查找第一个大于num的元素的位置。 换言之，假设本身数组或容器内不存在该元素，两个函数均返回可以插入该元素的位置。（即若存在，应该在哪个位置） 小技巧：通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 重载前提：针对从大到小排序的数组或容器，利用重载来实现查找 大同小异： lower_bound(left,right,num,greater&lt;type&gt;()); //查找第一个小于或等于num的元素位置 upper_bound(left,right,num,greater&lt;type&gt;()); //查找第一个小于num的元素位置 示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; bool cmp(int a, int b) { return a &gt; b; } int main() { int a[9]{}; for (int i = 0; i &lt; 9; i++) a[i] = rand() % 5 + 1; sort(a, a + 9); for (int i = 0; i &lt; 9; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; int pos1 = lower_bound(a, a + 9, 3) - a; cout &lt;&lt; pos1 &lt;&lt; \" \"; int pos2 = upper_bound(a, a + 9, 3) - a; cout &lt;&lt; pos2 &lt;&lt; endl; sort(a, a + 9, cmp); for (int i = 0; i &lt; 9; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; pos1 = lower_bound(a, a + 9, 3,greater&lt;int&gt;()) - a; cout &lt;&lt; pos1 &lt;&lt; \" \"; pos2 = upper_bound(a, a + 9, 3,greater&lt;int&gt;()) - a; cout &lt;&lt; pos2 &lt;&lt; endl; return 0; } 补充： partial_sumpartial_sum 是C++ STL 算法组件中的其中一个算法，其作用是计算某个序列局部元素的和。它有四个重载函数。要使用 partial_sum 需要引用头文件 numeric。 一般来说，使用partical_sum函数需要四个参数 partial_sum(容器要计算的起始位置，容器要计算的结束位置，结果存放的起始位置，自定义函数) 其中自定义函数可以留白，则默认计算局部和。而且，结果可以存放在原容器内。 示例如下： #include &lt;iostream&gt; #include &lt;numeric&gt; using namespace std; int cmp(int x, int y) { return x - y; } int main () { int test[10]; int ans[10]; for (int i = 0; i &lt; 10; i++) test[i] = rand() % 57; for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; partial_sum(test, test + 10, ans); for (int i = 0; i &lt; 10; i++) cout &lt;&lt; ans[i] &lt;&lt; \" \"; cout &lt;&lt; endl; partial_sum(test, test + 10, test, cmp); for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return 0; } 运行结果如下： 可以很直接看到用法，此函数通常可以用于前缀和，减少代码量。 max_element和min_element作用：返回最大值和最小值的地址 示例如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int main () { int test[10]; for (int i = 0; i &lt; 10; i++) test[i] = rand() % 57; for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; cout &lt;&lt; max_element(test, test + 10) &lt;&lt; endl;//输出地址 cout &lt;&lt; *max_element(test, test + 10) &lt;&lt; endl;//输出元素 cout &lt;&lt; max_element(test, test + 10) - test &lt;&lt; endl;//输出在数组中的位置 return 0; } 运行结果： END","categories":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"}],"author":"HeeKaai"},{"title":"STL入门---容器篇","slug":"STL入门-容器","date":"2022-01-30T13:15:10.000Z","updated":"2022-03-02T08:52:28.301Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://heekaai.github.io/posts/2.html","excerpt":"","text":"[TOC] 写在前面此文介绍STL中的容器部分，仅仅涉及入门知识及一些常见的用法。 vector vector 在英文中翻译为向量，但是在C++中把它叫做“变长数组”，更加容易理解它的用法。顾名思义：vector容器是长度根据需要而自动改变的数组。 如果要使用vector容器，需要在头文件里加上#include&lt; vector &gt; vector的定义讲vector的定义之前，可以先回顾一下数组的定义方法。 typename arrayname[arraysize]; //一维数组 typename arrayname[arraysize1][arraysize2]; //二维数组 下面再来看vector的定义： vector&lt;typename&gt; name; 和一维数组一样，typename可以是所有的基本类型，例如：int、double、char、结构体······当然也可以是STL中的其他容器，例如：vector、set、queue······ vector数组的定义 vector&lt;typename&gt; name[size]; 例如： vector&lt;int&gt; ve[100]; 这样ve[0]到ve[99]每一维都是一个vector容器。 当然，如果我们把typename也改成vector容器，同样可以实现二维数组的功能。 vector&lt;vector&lt;int&gt;&gt; name; 这样数组的两个维度都是“变长”的。而vector&lt;typename&gt; name[size]其中一维的长度就已经固定了。稍微体会一下这两者的区别。 访问vector容器中的元素vector容器有两种访问方式：通过下标或者迭代器访问。下面分别讲到这两种访问方式。 通过下标访问 和访问普通的数组一样，对于一个定义为vector&lt;int&gt;ve的vector容器而言，直接访问ve[index]即可。当然这个下标访问和普通数组一样是从0~~ve.size（）-1，也需要注意存在越界的问题。 通过迭代器访问 迭代器（iterator）可以理解为一个类似于指针的东西，其定义为： vector&lt;typename&gt;::iterator it; 这样定义之后 i t 就是vector&lt;typename&gt;::iterator 型的变量。也即迭代器 i t ，并且可以通过*i t来访问vector中的元素。 比如说： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=0;i&lt;6;i++) ve.push_back(i); //后面会提，在ve的末尾添加元素i for(int i=0;i&lt;6;i++) cout&lt;&lt;ve[i]&lt;&lt;\" \"; cout&lt;&lt;endl; vector&lt;int&gt;::iterator it=ve.begin(); //it指向ve的首地址 for(int i=0;i&lt;6;i++) cout&lt;&lt;*(it+i)&lt;&lt;\" \"; cout&lt;&lt;endl; return 0; } 从上面给出的例程，可以看出ve[i]和*(it+i)是等价的。 上面的代码中出现了ve.begin（），其作用是取到vector容器的首地址。而ve.end（）却不是取到vector容器的末尾地址，而是末尾元素的下一个地址。 另外，需要注意的还有迭代器还支持自加和自减操作，则遍历vector容器还有第三种写法： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=0;i&lt;6;i++) ve.push_back(i); vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; cout&lt;&lt;endl; return 0; } vector容器的常用函数 push_back（） 上面的代码就已经使用过这种方式添加过元素了。很简单，和函数名一样，push_back(x) 的作用就是在 vector 容器最后添加上元素 x ，时间复杂度是 O（1） 。 pop_back（） 有添加作用的函数自然，相对的肯定会有删减作用的函数。pop_back（） 用以删除vector容器中的最后一个元素，时间复杂度同样为 O（1）。 比如说： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it; cout&lt;&lt;\" \"; } putchar('\\n'); ve.pop_back(); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it; cout&lt;&lt;\" \"; } putchar('\\n'); return 0; } size（） size（）函数用以获取vector容器中的元素个数。 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } cout&lt;&lt;ve.size()&lt;&lt;endl; return 0; } clear（） clear（）用以清空vector容器中的所有元素，时间复杂度是 O（N) ，其中N是vector容器中的元素个数。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } cout&lt;&lt;ve.size()&lt;&lt;endl; //输出5 ve.clear(); cout&lt;&lt;ve.size()&lt;&lt;endl; //输出0 return 0; } insert（） insert（it,x）用以向vector容器的任意迭代器it位置插入一个元素x，时间复杂度为 O（N)。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; it=ve.begin()+2; //*** ve.insert(it,-1); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 -1 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } 需要特别说明的是，代码中注释标注为三个*的地方，在常用的STL容器中，只有在string和vector中，才允许使用ve.begin（）+2这种迭代器直接加上整数的写法！ erase（） erase（）也是一种删除函数，它有两种使用方法：删除单个元素以及删除一个区间内的所有元素。时间复杂度自然也是 O（N)。 （1）删除单个元素： erase（it）即删去迭代器 it 处的元素。 例如： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; it=ve.begin()+2; ve.erase(it); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } （2）删除一个区间内的所有元素 遵循着“左闭右开”的原则，erase（left,right）即删去[first,right)内vector容器中的所有元素。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; ve.erase(ve.begin()+1,ve.begin()+4); //删去下标为[1,4)的元素 for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } 所以清空vector容器除了上面提到的clear()函数外，现在也可以使用第二种方法：ve.erase（ve.begin（）,ve.end（））。这样只是加深对“左闭右开”的理解，因为ve.end（）指向的是末尾元素的下一个位置。当然clear（）函数明显更加方便、简洁。 string在C语言中，通常使用字符数组char s[] 来对字符串进行存储，在此基础上为了对字符串的操作更加的快捷、方便，C++在STL中加入了string类型，对字符串的常用功能进行了封装。如果要使用string，需要添加头文件&lt;string&gt;（注意string.h和string是完全不一样的头文件）。下面来看看string容器的常用使用方法吧。 string的定义定义 string 的方式和其他的基本数据类型一致，只需要在 string 后面加上变量的名称即可。如果要进行初始化，定义时直接进行赋值即可。 string str; //定义 string str=\"abcd\"; //赋值 访问string容器中的元素（1）通过下标访问： 一般而言，可以像访问字符数组那样通过下标对string容器进行访问。 （2）通过迭代器访问： 定义迭代器： string::iterator it; //string类型无其他参数 关于使用迭代器对string容器中的元素进行访问的方法，类似于上文中的vector容器，在这里就不做过多阐述，可以参照上文。 如果要读入和输出整个字符串，则只能使用cin和cout。 最后需要注意的一点，string和vector一样，支持直接对迭代器进行加减某个数字，比如说str.begin（）+2 的写法是合法的。而对于STL的其他容器，则不支持这种写法。 string容器的常用函数（1）比较与拼接 因为 string 在C++中是一种数据类型，则可以像其他的变量一样进行加法运算及比较运算（比较的是字典序）。比如说： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abc\",str2=\"123\"; string str; str=str1+str2; cout&lt;&lt;str&lt;&lt;endl; //输出abc123 string str3=\"aaabc\",str4=\"aabc\"; cout&lt;&lt;(str3&gt;str4)&lt;&lt;endl; //返回0，str3字典序大于str4 return 0; } （2）length（）和 size（）函数 这两个函数都是返回 string 的长度，作用和运行效率基本相同。 （3）insert（）函数 string的insert（）函数，常见的写法有两种。 ①insert（pos，string），pos为string容器中的位置，string为待插入的字符串。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abcde\",str2=\"123\"; str1.insert(3,str2); //在str[3]处插入了“123” cout&lt;&lt;str1&lt;&lt;endl; //输出abc123de } ②insert（it，it2，it3）使用三个迭代器的写法，it 指向原字符串待插入的位置，it1、it2指向待插字符串的首尾元素，来表示串 [ it1,it2 )插入到 it 位置。（左闭右开原则） #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abcde\",str2=\"123\"; str1.insert(str1.begin()+3,str2.begin(),str2.end()); cout&lt;&lt;str1&lt;&lt;endl; //abc123de } （4）erase（）函数 （5）clear（）函数 这两个函数用法和vector容器的用法一致，可以参照上文。 （6）substr（）函数 substr（pos，len）返回从pos号位置开始，长度为len的子串。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a nice day\"; cout&lt;&lt;str.substr(0,5)&lt;&lt;endl; //输出Today cout&lt;&lt;str.substr(11,4)&lt;&lt;endl; //输出nice } （7）find（）函数 str.find（str1)，即在str中找是否存在子串str1，若存在则返回子串首次出现的位置，否则返回string::npos常数（最大的unsigned_int，也相当于-1。） str.find（str1，pos)即将开始查找的位置定为pos，返回值和上面相同。 时间复杂度为 O（mn） 故使用需谨慎考虑时间复杂度。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a nice day\"; cout&lt;&lt;str.find(\"nice day\")&lt;&lt;endl; //返回11 cout&lt;&lt;str.find(\"bad day\")&lt;&lt;endl; if(str.find(\"bad day\")==-1)cout&lt;&lt;\"-1\"&lt;&lt;endl; } （10）replace（）函数 str.replace（pos，len，str1）把str的pos号位置开始，长度为len的子串替换为str1。 str.replace（it1，it2，str1）把str [ it1，it2 ) 替换为str1。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a bad day\"; cout&lt;&lt;str&lt;&lt;endl; string str1=\"nice\",str2=\"Tomorrow\"; str.replace(11,3,str1); cout&lt;&lt;str&lt;&lt;endl; //输出 Today is a nice day str.replace(str.begin(),str.begin()+5,str2); cout&lt;&lt;str&lt;&lt;endl; //输出 Tomorrow is a nice day } setset在英文中翻译为集合，是一个内部自动有序且不含重复元素的容器。如果要使用set容器，则需要在头文件中添加&lt; set &gt;。 set的定义set的定义的写法其实和vector基本上是一样的，或者说大部分STL容器都是这样定义的。 #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;typename&gt; name; //一维 set&lt;typename&gt; arrayname[arraysize]; //二维 } set容器内元素的访问set 容器内的元素只能通过迭代器进行访问。且 set 容器不支持*（it+i）的访问方式，因此常用的枚举方式如下： #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; //定义set容器 st.insert(2); //用insert插入元素 st.insert(1); st.insert(3); st.insert(2); set&lt;int&gt;::iterator it; //定义迭代器 for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 cout&lt;&lt;endl; } 从输出结果可以发现，set容器内部自动实现了递增排序且删除了重复的元素。 set容器常用函数 insert（） insert（x）可将x插入容器中，且实现自动升序和去重，时间复杂度是O（logN）其中 N 是当前容器中的元素个数。 find（） find（x）返回set容器中对应值为x的迭代器（而不是下标 string返回的是对应下标），时间复杂度是O（logN）其中 N 是当前容器中的元素个数。 earse（） 同样，erase函数有两种用法：单个元素和区间元素删除。 （1）删除单个元素： erase（it）即删去迭代器 it 处的元素。可结合find（）函数进行使用。 示例如下： #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; for(int i=1;i&lt;5;i++) st.insert(i); set&lt;int&gt;::iterator it; it=st.find(3); st.erase(it); for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 cout&lt;&lt;endl; } erase（value），value为待删除元素的值。时间复杂度为O（N) #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; for(int i=1;i&lt;5;i++) st.insert(i); set&lt;int&gt;::iterator it; st.erase(3); for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 cout&lt;&lt;endl; } （2）删除一个区间内的所有元素 用法和上文提到的vector容器的用法一致，可以参照上文。 size（） clear（） 用法同样是类似的，在这里就不做过多的阐述了。 mapmap在英文中翻译为映射，也是常用的STL容器。 一个简单的引入：在定义数组时（比如说int array[ 100 ]),其实就可以理解为一个int -&gt; int 的映射。而map容器则可以将任何数据类型映射到任何数据类型（当然也包括STL容器）。 map容器的定义单独定义一个map： map&lt;typename1,typename2&gt; mp; 我们把映射前类型称为键（key），映射后类型称为值（value）。 特别说明：当字符串作为键值时，不能使用char[ ]型的数组，而应该是使用string容器。并且，map中的键是唯一的，和数学中的映射概念是一致的。 map容器内元素的访问map容器一般有两种访问方式：通过下标访问或通过迭代器访问。下面来讨论这两种访问方式。 （1）通过下标访问 和引入部分提到的，就和访问普通的数组是一样的，可以通过下标进行赋值和访问。 #include&lt;iostream&gt; #include&lt;map&gt; //记得添加头文件 using namespace std; int main () { map&lt;char,int&gt;mp; char ch='a'; for(int i=1;i&lt;=26;i++) { mp[ch]=i; //赋值 ch++; } cout&lt;&lt;mp['h']&lt;&lt;\" \"&lt;&lt;mp['k']&lt;&lt;endl; //输出8 11 return 0; } （2）通过迭代器访问 map容器的迭代器定义方式和其他STL容器迭代器定义方式相同。 但是因为在定义时有两个数据类型，所以在使用map容器的迭代器时，可以使用 it -&gt; first 来访问键，使用 it -&gt; second 来访问值。 例如： #include&lt;iostream&gt; #include&lt;map&gt; using namespace std; int main () { map&lt;char,int&gt;mp; char ch='a'; for(int i=1;i&lt;=5;i++) { mp[ch]=i; ch++; } map&lt;char,int&gt;::iterator it; for(it=mp.begin();it!=mp.end();it++) { cout&lt;&lt;it -&gt; first&lt;&lt;\" \"&lt;&lt;it -&gt; second&lt;&lt;endl;//输出a-e 1-5 } return 0; } 虽然上面代码赋值是从小到大，但是实际上map容器的键值会以从小到大的顺序自动排序（类似于 set容器内部使用红黑树来实现）。 map容器常用函数 find（）函数 find（key）返回键值为key的映射的迭代器，时间复杂度为O（logN） erase（）函数 mp.erase（x）其中x可以为键值或者迭代器 区间删除类似于set容器，可以参照上文的set容器。 size（）函数 得到的是映射的对数 clear（）函数 用法同样类似，在此不做赘述。 stack stack的英文翻译是栈，是STL中实现后进先出的容器。 stack定义stack定义方法和上面提到的容器类似，typename可以是任意的数据类型。使用stack容器时，头文件一定不要忘记添加#include&lt; stack &gt; stack容器内元素的访问由于stack容器后进先出的特性，故只能通过top（）来访问栈顶元素 简单例子： #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main () { stack&lt;int&gt; st; for(int i=0;i&lt;5;i++) st.push(i); cout&lt;&lt;st.top()&lt;&lt;endl; //输出 4 } 从上面这个例子不难看出stack容器后进先出的特性以及top（）函数的用法。 stack容器常用函数的使用 push（） push（x）将元素x入栈，时间复杂度为 O（1） top（） 获取栈顶元素 pop（） 弹出栈顶元素 empty（） 用以检查栈内元素是否为空，若为空即返回true，否则返回false。 size（） 返回容器内的元素个数 queue queue的英文翻译是队列，是STL中实现先进先出功能的容器。 queue容器的定义首先还是要提醒使用时记得添加头文件#includ&lt; queue &gt;，其余写法和其他的STL容器类似。 queue容器内的元素访问参照栈，由于队列具有先进先出的特性，所以queue容器只允许通过front（）和back（）来访问队列中对首元素和队尾元素。 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { queue&lt;int&gt;q; for(int i=0;i&lt;5;i++) q.push(i); cout&lt;&lt;q.front()&lt;&lt;\" \"&lt;&lt;q.back(); //输出： 1 5 return 0; } queue常用函数 push（） front（）、back（） 以上函数在上面示例可以看到简单用法 pop（） pop（）函数令队首元素出队，时间复杂度是O（1） empty（） 检查queue容器内是否为空，若为空返回true，否则返回false size（） 返回queue容器内的元素个数。 priority_queuepriority_queue又称为优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是优先级别最高的元素。当然这里的优先级则是规定出来的。 priority_queue容器的定义定义方式和queue容器的定义方式相同 priority_queue容器内元素的访问和queue容器不同的是，priority_queue容器并没有front（）函数和back（）函数，只能通过top（）函数来访问其堆顶元素（即优先级别最高的元素） 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { priority_queue&lt;int&gt;pq; for(int i=0;i&lt;5;i++) pq.push(i*2); for(;;) { if(pq.empty())break; cout&lt;&lt;pq.top()&lt;&lt;\" \"; pq.pop(); } cout&lt;&lt;endl; //输出： 8 6 4 2 0 return 0; } 可以发现，在未涉及优先级时，用法是和queue容器大同小异的。 priority_queue容器的常用函数 push（） top（） pop（） empty（） size（） 以上函数都可以在上面的示例当中看到简单应用。 priority_queue内元素的优先级的设置如何定义优先队列中的元素优先级是运用好优先队列的关键，下面来介绍设计首先队列元素的优先级别的方法。 基本数据类型的优先级设置这里提及的基本数据类型包括：int、char、double，优先队列对其默认是数字越大的优先级别越高（char型则比较的是字典序），则默认写法的详细写法为： priority_queue&lt;int&gt; name; priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; name; //以上两种写法是完全等价的 若使用char或double则将int全部改为char或double即可。 若想设置数字越小优先级别越高，将less&lt; int &gt;替换为greater&lt; int &gt;即可 #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;pq; for(int i=0;i&lt;5;i++) pq.push(i*2); for(;;) { if(pq.empty())break; cout&lt;&lt;pq.top()&lt;&lt;\" \"; pq.pop(); } cout&lt;&lt;endl; //输出0 2 4 6 8 return 0; } 结构体的优先级的设置引入一个小小的例子，对商品的名称及价格建立一个结构体，并且规定价格高的商品优先级别更高。 struct goods{ string name; int price; }; //定义结构体 为实现优先级的规定，必须在结构体中添加比较功能。 struct goods{ string name; int price; friend bool operator &lt; (goods g1, goods g2){ return g1.price &lt; g2.price } //重载小于号“&lt;” }; 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;string&gt; using namespace std; struct goods { int price; string name; friend bool operator &lt; (goods g1, goods g2) { return g1.price&lt;g2.price; } }; int main () { goods g1,g2,g3; priority_queue&lt;goods&gt; q; g1.name=\"milk\";g1.price=10; g2.name=\"apple\";g2.price=8; g3.name=\"meet\";g3.price=12; q.push(g1); q.push(g2); q.push(g3); for(;;) { if(q.empty())break; cout&lt;&lt;q.top().name&lt;&lt;\" \"&lt;&lt;q.top().price&lt;&lt;endl; q.pop(); } return 0; } //输出： meet 12 milk 10 apple 8 这里的重载符号的作用其实和sort函数中的cmp函数相似，但是实现的效果两者是相反的（在排序中return的是“&gt;”那么就是从大到小排序），这一点需要特别注意。 pair同样顾名思义，pair的英文翻译是：一对、一双，也即把两个元素绑在一起当作一个合成元素。可以理解为一个内部有两个元素的结构体。 pair的定义要使用pair容器首先必须添加头文件#include&lt; utility &gt;，需要注意的是，由于map容器的内部涉及到了pair，所以如果头文件中添加了#include&lt; map &gt;就可以直接使用pair容器。 对比结构体和pair： struct pair{ typename1 first; typename2 second; } pair&lt;typename1,typename2&gt; name; pair容器内元素的访问pair容器内只存在两个元素，访问方式和结构体访问方式类似。 示例如下： #include&lt;utility&gt; #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; int main () { pair&lt;string,int&gt;p(\"abc\",123); cout&lt;&lt;p.first&lt;&lt;\" \"&lt;&lt;p.second&lt;&lt;endl; return 0; } pair容器常用函数 比较操作数 两个pair类型数据可以直接使用==、！=、&lt;等比较大小，比较规则是先比较first，在first相同的情况下才去比较second的大小。 作为map的键值进行插入 listlist容器的定义list是双向循环列表，每一个元素都知道前一个元素和后一个元素，所以和vector相比，list能够更快的插入和删除，但是随机访问却比较慢。 定义与初始化： list&lt;typename&gt; lis1;//创建空的list list&lt;typename&gt; lis1(n);//创建含有n个元素的list list&lt;typename&gt; lis1(n,val);//创建n含有n各元素且值为val的list list&lt;typename&gt; lis1(lis2);//用lis2初始化lis1 list的访问与常用函数 assign（）函数用于赋值 begin（），end（）返回首尾元素的迭代器 front（），back（）返回首尾元素 size（）返回容器的元素个数 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis1; list&lt;int&gt;lis2(4, 10); int num[6] = {2, 17, 4, 55, 78, 16}; lis1.assign(lis2.begin(), lis2.end()); list&lt;int&gt;::iterator it; for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; //输出：10 10 10 10 cout &lt;&lt; endl; lis1.assign(num, num + 6); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \";//输出：2,17,4,55,78,16 cout &lt;&lt; endl; return 0; } erase（）动态删除，返回当前迭代器的下一个节点（返回迭代器）。区间删除，单个删除均可以实现。 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis; for (int i = 1; i &lt;= 8; i++) lis.push_back(i); list&lt;int&gt;::iterator it, it1, it2; for (it = lis.begin(); it != lis.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \" ;//输出： 1 2 3 4 5 6 7 8 cout &lt;&lt; endl; it1 = it2 = lis.begin(); advance(it2, 6); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl; //输出 1 7 it1 = lis.erase(it1); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl; //输出 2 7 it2 = lis.erase(it2); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl;// 输出 2 8 it1++; it2--; lis.erase(it1, it2);//输出2 6 8 for (it = lis.begin(); it != lis.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \" ; cout &lt;&lt; endl; return 0; } insert（）插入元素 单个元素以及区间插入均可实现 特别注意：返回的迭代器是原来的位置，插入的坐标迭代器指向的元素不变。 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis; for (int i = 1; i &lt;= 6; i++) lis.push_back(i); list&lt;int&gt;::iterator it = lis.begin(), it1; it1 = lis.insert(it, 10); cout &lt;&lt; *it &lt;&lt; endl &lt;&lt; *it1 &lt;&lt; endl;//it指向1 it1指向10 return 0; } merge（）合并两个list reverse（）倒转list END","categories":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"}],"author":"HeeKaai"},{"title":"C语言期末复习笔记","slug":"C语言期末复习笔记","date":"2022-01-06T15:24:12.000Z","updated":"2022-01-10T06:24:58.032Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://heekaai.github.io/posts/1.html","excerpt":"","text":"[TOC] 前言​ 临近期末考试（C语言程序设计），本人也是从暑假（7月份）开始接触的C语言，可以说是一只纯正的小白，为了更好、更有效率的备考，这篇博客也就由此诞生了。 ​ 顺序没啥讲究，完全是想到了什么就写出来了。很多算法优化空间还有很大。 动态规划初步​ 动态规划其实我感觉也可以叫作记忆化的递归优化，顾名思义，就是一种把递归可能会产生的重复运算记录下来，以空间换时间（当然空间复杂度的代价也是可以降到最小的，比如说滚动数组来实现）。 DP的组成部分​ 几乎每一道可以用动态规划来解决的题目，设计算法的时候都可以被拆解为以下的几步： 确定状态（定海神针的作用） 最后一步 子问题 （由最后一步将问题分解，即解决子问题+最后一步） 确定状态转移方程 子问题定下来，状态转移就是子问题的一般化过程 初始化与边界 计算顺序 这四步听起来好像不太好理解，但是动态规划的核心就在这。通过题目应该可以更好的思考和理解动态规划的组成部分。 例题坐标型DP题目描述： 如图，A 点有一个过河卒，需要走到目标 B 点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如上图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图 C 点上的马可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。 棋盘用坐标表示，A 点（0,0）、B 点（n,m）(n,m 为不超过 20 的整数，并由键盘输入)，同样马的位置坐标是需要给出的（约定: C&lt;&gt;A，同时C&lt;&gt;B）。现在要求你计算出卒从 A 点能够到达 B 点的路径的条数。 输入描述： 输入B点的坐标（n,m）以及对方马的坐标（X,Y） (不用判错) 输出描述： 输出一个整数表示路径的条数。 样例输入： 6 6 3 2 样例输出： 17 原题链接：Nowcoder-过河卒 题目分析： 参照上面的DP组成部分，一步一步来： 最后一步：最后一定会到达（n，m）的位置 子问题：在没有马控制的前提下，一定是由（n-1，m）或者（n，m-1）过来 状态转移方程：dp[i] [j]=dp[i-1] [j]+dp[i] [j-1] 初始化与边界：首先马的领地是不能到的，直接记为0；然后就是第一行和第一列都是1；在初始化第一行第一列的时候，遇到马就直接break，因为后面的都到不了了； AC代码： #include&lt;stdio.h&gt; #include&lt;stdbool.h&gt; #include&lt;string.h&gt; long long dp[25][25]; bool judge[25][25];//判断是否为马的领地，布尔数组合适 int main () { memset(judge,true,sizeof(judge)); int n,m,x,y; scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;x,&amp;y); judge[x][y]=0; judge[x-2][y-1]=judge[x-2][y+1]=judge[x-1][y-2]=judge[x-1][y+2]=0; judge[x+2][y-1]=judge[x+2][y+1]=judge[x+1][y-2]=judge[x+1][y+2]=0; for(int i=0;i&lt;=m;i++) { if(judge[0][i])dp[0][i]=1; else break; } for(int j=0;j&lt;=n;j++) { if(judge[j][0])dp[j][0]=1; else break; } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(judge[i][j])dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } printf(\"%lld\\n\",dp[n][m]); } 序列DP原题链接：XTUOJBlocks 题目描述： 给你一个n块积木，每个积木块都是立方体，现在把它们排列一排，成m列，要求每列上至少有1个积木，且从左到右，每列的积木数量呈严格单调下降。 ​ 题意即求n等于m个不同的数相加的方案数 最后一步：m个数不同，则一定有最大的数，记为k。 子问题：则求解n-k等于m-1个不同的数相加的方案数。 状态转移方程：$$dp(i,j,k)=\\sum_{t&lt;k}dp(i-k,j-1,t)$$ 初始化与边界：m=1时方案数为1 代码： #include &lt;stdio.h&gt; int dp[101][11][101]; int main() { dp[1][1][1]=1; for(int i=2;i&lt;101;i++) { for(int j=1;j&lt;11;j++) { for(int k=1;k&lt;=i;k++) { if(j==1&amp;&amp;k==i) { dp[i][j][k]=1; continue; } for(int r=1;r&lt;k;r++) { dp[i][j][k]+=dp[i-k][j-1][r]; } } } } int T,n,m; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;n,&amp;m); int ans=0; for(int i=1;i&lt;=n;i++) { ans+=dp[n][m][i]; } printf(\"%d\\n\",ans); } return 0; } 变式：XTUOJ积木Ⅱ 题目描述： n个积木，分成m垛，这些积木垛排成一行，使得所有垛的积木块数不相同，且呈“山“字形（积木数先单调上升，再单调下降）。现在已知n,m,请求方案数。 ​ 有上面这题的基础，这题也就不难了 ​ 大体思路：有了n个数等于m个不同的数相加的方案数，对于这个单调的序列，除了最大的数以外，每个数都有两个选择 留在左边 或者放到右边 两个选择。但是不能全留也不能全走。$$f(i,j)=(2^{j-1}-2)*\\sum_{k=1}^idp(i,j,k)$$ AC代码： #include &lt;stdio.h&gt; int dp[101][11][101]; int mi(int x) { int res=1; for(int i=0;i&lt;x;i++) res*=2; return res; } int main() { dp[1][1][1]=1; for(int i=2;i&lt;101;i++) { for(int j=1;j&lt;11;j++) { for(int k=1;k&lt;=i;k++) { if(j==1&amp;&amp;k==i) { dp[i][j][k]=1; continue; } for(int r=1;r&lt;k;r++) { dp[i][j][k]+=dp[i-k][j-1][r]; } } } } int T,n,m; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;n,&amp;m); int ans=0; for(int i=1;i&lt;=n;i++) { ans+=dp[n][m][i]; } ans*=(mi(m-1)-2); printf(\"%d\\n\",ans); } return 0; } ​ 当然动态规划内容远比这多，只是在这里给大家提供一种思想，遇到动态规划，往这四个组成部分上面去靠去思考准没错。 ​ 动态规划敬请期待后续文章。 排序篇选择、插入排序​ 冒泡、选择、插入排序是比较基础、简单的一类排序方法，相对的，它们的执行效率也会相对比较低。在不做优化的情况下，时间复杂度会达到 O（n^2） 的级别，这在很多情况下都是难以接受的。 选择排序​ 选择排序（Selection-sort）是一种简单直观的排序算法。 ​ 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。每一次从无序组的数据元素中选出最小的一个元素，存放在无序组的起始位置，无需组的元素减少，有序组的元素增加，直到全部待排序的数据元素排完。 #include &lt;stdio.h&gt; //选择排序 void selectSort(int arry[], int len) { int i; int j; for ( i = 0; i &lt; len-1; i++) { int min = i;//假设第一个元素是最小的 for (j = i + 1; j &lt; len; j++) { if (arry[j] &lt; arry[min]) { min = j;//保存最小元素的下标 } } //交换 int temp = arry[min]; arry[min] = arry[i]; arry[i] = temp; } } //输出 void print(int arry[], int len) { for (int i = 0; i &lt; len; i++) { printf(\"%d \", arry[i]); } } int main() { int arry[10]={15,36,26,27,24,46,44,29,52,48}; selectSort(arry,10); print(arry,10); printf(\"\\n\"); return 0; } 插入排序​ 插入排序是最简单常用的方法，将数组分为两部分，排好序的数列，以及未排序的数列，将未排序的数列中的元素 与排好序的数列进行比较，然后将该元素插入到已排序列的合适位置中。 #include &lt;stdio.h&gt; //插入排序 void insertSort(int arry[], int len) { int i; int temp;//保存要插入的元素 int j;//从当前要要比较插入的元素的前面一个开始 for ( i = 1; i &lt; len; i++)//第一个元素视为有序,把后面的元素一个一个的插入到前面 { temp = arry[i]; j = i - 1; while (j &gt;= 0&amp;&amp;arry[j]&gt;temp) { arry[j + 1] = arry[j];//前面的元素往后面移动 j--; } arry[j + 1] = temp;//把要插入的元素,插入进对应的位置 } } //输出 void print(int arry[], int len) { for (int i = 0; i &lt; len; i++) { printf(\"%d \", arry[i]); } } int main() { int arry[10]={3,44,38,5,47,15,36,26,27,2}; insertSort(arry,10); print(arry,10); printf(\"\\n\"); return 0; } 快速排序​ quicksort快速排序，qsort()是c语言的库函数，在头文件&lt;stdlib.h&gt;中，基于二分的思想，所以执行效率非常的优秀，务必掌握。 ​ qsort()函数的四个参数： 数组名（待排元素的首地址） 待排元素的个数 数据类型所占字节大小 cmp函数 int cmp(const void *a, const void *b) //格式是固定不变的 int 型模板： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int cmp(const void *a,const void *b) { int *pa=(int *)a; //强制类型转换 int *pb=(int *)b; return *pa-*pb; } int main () { int a[5]={5,3,45,78,9}; qsort(a,5,sizeof(int),cmp); //传参形式 for(int i=0;i&lt;5;i++) printf(\"%d \",a[i]); printf(\"\\n\"); return 0; } ​ 若想要实现降序，只需将cmp函数的返回值改为相反数即可。 ​ 相应的，char型字符数组，要实现排序，只需要改动cmp函数里的强制类型转换部分。 二维int型#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define N 4 int cmp(const void *a,const void *b) { int *pa=(int *)a; int *pb=(int *)b; int i=0; for(;i&lt;N&amp;&amp;*pa==*pb;i++,pa++,pb++); if(i==N) return 0; else return *pa-*pb; } void prt(int (*a)[N],int n){ int i,j; for(i=0;i&lt;n;i++){ for(j=0;j&lt;N;j++) printf(\"%d \",a[i][j]); printf(\"\\n\"); } printf(\"\\n\"); } int main(){ int a[5][N]={{1,7,3,4},{1,5,4,3},{2,5,3,7},{2,5,3,8},{1,7,4,3}}; prt(a,5); qsort(a,5,sizeof(a[0]),cmp); prt(a,5); return 0; } 字符串​ 利用&lt;string.h&gt;头文件里现成的比较函数strcmp（）函数即可。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int less(const void *a,const void *b){ char *pa,*pb; pa = (char *)a; pb = (char *)b; return strcmp(pa,pb); } void prt(char (*a)[20],int n){ int i; for(i=0;i&lt;n;i++) puts(a[i]); printf(\"\\n\"); } int main(){ char a[10][20]={\"Hello\",\"Hell\",\"Her\",\"He\",\"His\",\"Hers\",\"Helm\",\"Heat\",\"Heal\",\"Heap\"}; prt(a,10); qsort(a,10,sizeof(a[0]),less); prt(a,10); return 0; } 数学问题最大公约数与最小公倍数最大公约数​ 一般用 gcd（a,b） 来表示 a 和 b 的最大公约数，而求解最大公约数的方法通常是欧几里得算法（即辗转相除法） ​ 欧几里得算法基于如下定理：$$gcd(a,b)=gcd(b,amodb)$$ ​ 证明过程暂且省略，并且容易得知gcd（a , 0）= 0 。所以很明显是一个是一个递归，递归式和边界都已得到，则可以写出代码的模板： int gcd(int a,int b) { if(b==0) return a; else return gcd(b,a%b); } ​ 当然，引进中间变量的写法也是可以的： int gcd(int a,int b) { int t; while (b!=0) { t=a%b; a=b; b=t; } return a; } ​ 选择任意一种方便自己记忆的写法即可。 最小公倍数​ 最小公倍数在最大公约数的基础上进行，一般用 lcm（a , b）表示 a 和 b 的最小公倍数。 ​ 若将 a 和 b 的最大公约数记作 c 的话，最小公倍数自然就是 a*b / d ，但是这样写a * b在计算的过程中容易溢出，更好的写法是 （a/d）*b 。 素数​ 素数的定义都熟，也就不再赘述了。特别注意，1既不是素数也不是合数。 ​ 应对期末考试里面有关素数的题目，打素数表显然是一种最好的方法，目前还没有出现过问题，属于是百试不爽了。 ​ 打素数表，首推的是筛法求解，这样进一步把时间复杂度降低了。一般就选埃氏筛和欧拉筛（时间复杂度都可以达到线性）。但是我用欧拉筛比较多一点，所以这里就放欧拉筛的代码模板了。 ​ 还要表明的一点就是，因为是线性打表，所以有空间上的限制，一般到1e7都是不会出问题的，更大的话编译就会报错了。 ​ 模板如下： #define N 1000007 bool num[N]; //在&lt;stdbool.h&gt;里 int prime[N]; int main () { memset(num,true,sizeof(num)); //在&lt;string.h&gt;里 num[1]=false; int cnt=0; for(int i=2;i&lt;N;i++) { if(num[i]==true)prime[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;prime[j]*i&lt;N;j++) { num[i*prime[j]]=false; if(i%prime[j]==0)break; } } } ​ 对于上面模板，prime里面所有数都是有序素数，num下标用以判断是否为素数。还要一点需要注意，N开的时候至少要比n大1。 质因子分解 唯一分解定理： ​ 每个大于1的自然数，要么本身就是质数，要么可以写为2个或以上的质数的积，而且这些质因子从小到大排序，写法仅有一种方式。 ​ 个人感觉这个知识点也是期末考试里比较常见的考点。 ​ 由上面唯一分解定理不难看出，在做质因子分解有关题目时，还得借助上面提到的素数部分内容，必须提前打好素数表。 ​ Tips： ​ 对于一个正整数 n 来说，如果它存在 1 和本身以外的因子，那么是一定在sqrt（n）的左侧和右侧成对出现（这就是判断 n 是否为素数时只要从1 - sqrt（n）的原因）。 ​ 把这个结论用在质因子分解上面：对于正整数 n（n≥2）言,至多只存在一个大于sqrt（n）的质因子，其余的质因子全部小于等于sqrt（n）。 ​ 所以质因子分解的核心思路就出来了： ​ 枚举 1 ~ sqrt（n）的所有质数 ​ 记质因子为p，考虑到有多个相同的质因子，所以重复直至无法整除。 ​ 如果上述步骤结束后， n 仍然大于 1 ，说明 n 有且只有一个大于sqrt（n）的质因子，如果 n 是素数，则就是 n 本身。 例题XTUOJ1396 题目描述： 根据质因子唯一分解定理可知$$n=\\prod_{i=1}^mpi^{ki}$$其中 pi 为素数。 $$定义g(n)=\\sum_{i=1}^{m}ki,求\\sum_{i=a}^bg(i)$$ 输入与输出： 输入：第一行是一个整数T（1≤T≤10000），表示样例的个数。 以后每行两个整数a,b（1≤a≤b≤10^6）。 输出：每行输出一个样例的结果。 样例输入与输出 输入： 2 1 2 1 1000000 输出： 1 3626619 ​ 感觉这题就是考察上面提到的东西，区间的那一段，就用前缀和解决即可。直接看代码吧，注释部分解释的很详细。 AC代码： #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdbool.h&gt; #define N 1000007 bool num[N]; int prime[N]; int fact[N]; int sum[N]; void X() { // 打素数表，其实开到sqrt(n)即可，但是过了就懒得优化了 memset(num,true,sizeof(num)); int cnt=0; for(int i=2;i&lt;N;i++) { if(num[i]==true) prime[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;N;j++) { num[i*prime[j]]=false; if(i%prime[j]==0)break; } } // 找质因子个数 int count=0; for(int i=2;i&lt;N;i++) { count=0; //count作用是记录每个质因子个数，进入循环前记得清0 int k=i; for(int j=0;j&lt;cnt&amp;&amp;prime[j]*prime[j]&lt;=k;j++) { if(k%prime[j]==0) { while(k%prime[j]==0) { k/=prime[j]; count++; } } } if(k!=1)count++; //还剩下一个质因子 fact[i]=count; //用fact存放每个整数i的质因子个数，即g(i); } for(int i=2;i&lt;N;i++) sum[i]=sum[i-1]+fact[i]; //题目要求区间的和，显然前缀和比较合适 } int main () { X(); int T,a,b; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",(sum[b]-sum[a-1])); //前缀和 a-1 不要弄错 } return 0; } XTUOJ1377 同一个考点，解法非常相似。 组合数​ 打表是我最喜欢的方法，快并且简单！ ​ 数学原理就是杨辉三角呗 模板代码 long long num[65][65]; //一定记得开long long不然会爆 void F() { int i,j,k; for(i=0;i&lt;65;i++) { num[i][i]=1; num[i][0]=1; } for(i=1;i&lt;65;i++) for(j=1;j&lt;i;j++) num[i][j]=num[i-1][j]+num[i-1][j-1]; } 其他​ 数学问题当然还有很多，比如说分数的四则运算（可以转化成假分数的形式，加上最大公约数的化简基本上就能过），还有大整数的四则运算（感觉期末考试这个好像没考过，但是我也有一点点心得，以后可以总结一下，在这里就先不写出来了） 贪心简单贪心 ​ 贪心算法是求解一类最优化问题的方法，总是做出在当前看来是最好的选择（局部最优）。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。（“活在当下，及时享乐”）贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 ​ 解题的一般步骤是：​ 1.建立数学模型来描述问题；​ 2.把求解的问题分成若干个子问题；​ 3.对每一子问题求解，得到子问题的局部最优解；​ 4.把子问题的局部最优解合成原来问题的一个解。 ​ 看到子问题是不是又想到了动态规划。贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似于“自顶向下”，但是并不等待子问题求解完后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是只在上一步选择的基础上继续选择，因此整个过程以一种单链的流水方式进行，显然这种所谓 “最优选择” 的正确性需要用归纳法证明。（而证明过程往往会比贪心本身复杂）而动态规划不管是采用自底向上还是自顶向下的计算方式，都是从边界开始向上得到目标问题的解。也就是说，它总是会考虑所有子问题，并选择继承能得到最优结果的那个，对暂时没被继承的子问题，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。所以贪心是一种壮士断腕的决策，只要进行了选择，就不后悔；动态规划则要看哪个选择笑到了最后，暂时的领先说明不了什么。 ​ 贪心算法设计时往往无需加以证明，自己认为无法举出反例就可以放心大胆的去设计。 ​ 例题： 原题链接：Nowcoder字典序最大的子序列 题目描述： 给定字符串s（只包含小写字母），请求出最大子序列。 输入与输出： 输入一行一个字符串 s ，且1 &lt;= |s| &lt;= 100,000 输出字典序最大的子序列 样例： 样例1： 输入： ababba 输出： bbba 样例2： 输入： abbcbccacbbcbaaba 输出： cccccbba ​ 这题很简单，大家可以感受一下贪心。字典序最大是不是第一个字母的字典序越大就越好，所以就把当前序列中最大的字典序找出来即可。及时缩短字符串长度。 AC代码 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main () { char s[100007]; scanf(\"%s\",s); int len=strlen(s); char max='a'-1; int cnt[128]; memset(cnt,0,sizeof(cnt)); for(int i=0;i&lt;len;i++) { cnt[s[i]]++; if(max&lt;s[i])max=s[i]; } for(int i=0;i&lt;len;i++) { if(max==s[i]) printf(\"%c\",max); cnt[s[i]]--; if(cnt[max]==0) { for(;max&gt;='a';max--) { if(cnt[max])break; } } } printf(\"\\n\"); return 0; } 区间贪心​ 贪心算法思路都是相同的，区间贪心自然不例外，保证当下最优即可。 ​ 区间贪心即对于区间有交集的问题，如何求解最多有几个区间能够互不相交，或者如何用尽量少的区间表示这些区间。 ​ 也是拿一道例题说明： 原题链接：Nowcoder值周 题目描述： JC内长度为L的马路上有一些值周同学，每两个相邻的同学之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0,1,2,…L，都有一个值周同学。 由于水宝宝有用一些区间来和ssy搞事情，所以为了避免这种事走漏风声，水宝宝要踹走一些区域的人。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的人（包括区域端点处的两个人）赶走。你的任务是计算将这些人都赶走后，马路上还有多少个人。 输入与输出： 输入： 第一行有2个整数L和M，L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。 接下来的M行每行包含2个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标 输出： 1个整数，表示马路上剩余的人的数目。 样例： 样例1： 输入： 500 3 150 300 100 200 470 471 输出： 298 样例数据说明: 对于所有的数据，1≤L≤100000000 对于10%的数据，1&lt;=M&lt;=100 对于20%的数据，1&lt;=M&lt;=1000 对于50%的数据，1&lt;=M&lt;=100000 对于100%的数据，1&lt;=M&lt;=1000000 ​ 放上AC代码： #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #define N 2 int num[1000007][2]; int cmp(const void *a,const void *b) { int *pa=(int *)a; int *pb=(int *)b; int i=0; for(;i&lt;N&amp;&amp;*pa==*pb;i++,pa++,pb++); if(i==N) return 0; else return *pa-*pb; } int main () { int L,M; scanf(\"%d%d\",&amp;L,&amp;M); int ans=L+1; for(int i=0;i&lt;M;i++) scanf(\"%d%d\",&amp;num[i][0],&amp;num[i][1]); qsort(num,M,sizeof(num[0]),cmp); int l=num[0][0],r=num[0][1]; for(int i=1;i&lt;M;i++) { if(num[i][0]&lt;=r) //已经是有序的序列所以只会有三种情况 { if(num[i][1]&gt;r)r=num[i][1]; // 两端被包括在内的情况被这个if排除 } else{ ans-=(r-l+1); //两端也被去掉了+1不能漏 l=num[i][0]; r=num[i][1]; } } ans-=(r-l+1); //最后一组的区间没有减 printf(\"%d\\n\",ans); return 0; } ​ 这题要用到之前提到的快速排序。区间贪心部分的解释已经在代码注释中给出。 二分二分查找​ 二分查找是基于有序序列的查找算法，递增和递减原理上并无区别，代码上稍微改动即可，所以下面都一严格递增序列为例。 ​ 算法原理： [ left , right ]一开始定为整个序列的左端和右端区间，每次判断中间位置与x的大小关系，则会有以下几种情况出现： 其中 mid = （left + right） / 2 ，序列记为num[ ] 若 num[mid]==x 跳出 若 num[mid]&gt;x，则x在mid左边，right 更新为 mid-1 若 num[mid]&lt;x，则x在mid右边，left 更新为 mid+1 ​ 原理很好理解，代码也不难实现，所以这里就不放模板代码了，因为每次题目都不会考察的这么直白，不会直接考查找某某某元素，而是会绕着考，所以核心是要理解二分的思想，运用二分的思想从而达到降低时间复杂度的目的，因为二分每一步都能去除一般的区间，所以时间复杂度是 O (logn) 级别的，非常的高效！ 例题先放上原题链接：Nowcoder-华华给月月准备礼物 题目描述： 二月中旬虐狗节前夕，华华决定给月月准备一份礼物。为了搭建礼物的底座，华华需要若干根同样长的木棍。华华手头上有一些长度参差不齐的木棍，他想将每根都裁剪成若干段自己想要的长度，并丢掉多余的部分。因为华华的手很巧，所以他的裁剪过程不会有任何的失误。也就是说，对于一根长度为N的木棍，华华可以精准的将它们裁剪为若干段木棍，使它们的长度之和为N。华华不知道裁剪成多长比较好，所以干脆越长越好。不过由于华华有点强迫症，所以他希望长度为非负整数。保证所有木棍的原长也是非负整数。那么请问华华最终得到的每根木棍多长呢？ 输入： 第一行两个正整数N、K，表示木棍原本的根数和华华希望得到的木棍根数。第二行N个正整数 Li 表示每根木棍的初始长度。 数据备注： 1 ≤ N ≤ 2*1e5 ， 1 ≤ Li ≤ 1e9 ， 1 ≤ K ≤ 1e9 输出一行一个非负整数，表示华华最终得到的n根木棍的每根最大长度。 样例 示例1： 输入： 5 10 4 4 4 5 3 输出： 1 示例2： 输入： 5 3 1 2 3 4 5 输出： 3 ​ 题目分析： ​ 是不是咋一看很难和二分法联系上去，但是你仔细思考，还是很容易发现其和二分的联系的。很显然，（记每根木棍的长度为L，这样裁剪能够得到的木棍根数为K）随着 L 增大，那么可以得到的根数 K 会变小。从这个角度出发就可以想到本题可以通过二分L，判断 K 和目标值的大小关系，及时调整区间的左右端点值。 ​ 附上代码可能会更好理解。 ​ AC代码： #include&lt;stdio.h&gt; int N,K,L[200007]; //全局变量可以不需要重复传参 int C(int x) //计算根数的函数 { int ans=0; for(int i=0;i&lt;N;i++) ans+=L[i]/x; return ans; } int main () { scanf(\"%d%d\",&amp;N,&amp;K); int l=1,r=0; for(int i=0;i&lt;N;i++) { scanf(\"%d\",&amp;L[i]); if(L[i]&gt;r)r=L[i]; } r++; //这个细节要注意，最大的L是可以重复的，嫌麻烦可以直接把r开到1e9 while(l&lt;r) //这是个小小的转换 { int mid=(l+r)/2; int k=C(mid); if(k&lt;K) r=mid; else l=mid+1; } printf(\"%d\\n\",l-1); } ​ 解题的大体思路代码中用注释解释清楚了，只是最后的while循环那里有个小小的转换，题意满足要求最大的长度，不如转化成第一个不满足条件的长度，在用这个长度-1即可得到答案，这样的转换可以让代码变得更加简洁。 快速幂​ 快速幂其实就是二分的一个应用，就是一个小技巧吧，见过的就自然会用。基于二分的思想，因此也常称为二分幂。 题目链接：快速幂||取余运算 大体思路： 如果b是奇数$$a^b=a*a^{b-1}$$ 如果b是偶数$$a^b=a^{b/2}*a^{b/2}$$ ​ 经过一定次数的转换，b可以变到0。很明显是一种递归的思想，时间复杂度则是O（logb） 代码模板： long long fastPower(long long base, long long power,long long mod) { long long result = 1; while (power &gt; 0) { if (power % 2 == 1) { result = result * base % mod; } power = power / 2; base = (base * base) % mod; } return result; } ​ 当然快速幂也有一种迭代的写法，但是迭代和递归的写法在效率上区别不大，所以不在这里过多阐述。 后话​ 都是一些比较简单的知识和入门级别算法，大佬不喜勿喷。 ​ 感谢你能够看到这篇文章的最后！！这也算是个人的第一篇博客了，希望能够有所收获。文章里发现任何问题，一定记得联系我指出噢。","categories":[{"name":"C语言","slug":"C语言","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"算法笔记","slug":"C语言/算法笔记","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"C语言/算法笔记/基础","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"C","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"学习","slug":"学习","permalink":"https://heekaai.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"基础算法","slug":"基础算法","permalink":"https://heekaai.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"author":"HeeKaai"},{"title":"博客的诞生","slug":"博客的诞生","date":"2022-01-03T14:35:02.000Z","updated":"2022-01-19T02:20:57.023Z","comments":true,"path":"posts/3c47c717.html","link":"","permalink":"https://heekaai.github.io/posts/3c47c717.html","excerpt":"","text":"相遇就是缘！ 为什么要搭建博客？纯属自己的个人兴趣吧！记录自己最近都干了什么，学到了什么，或许会有一些成就感吧！拥有一个自己的博客写一写自己感兴趣或者正在研究的事或物，不是一件很有意义的事情嘛！ 展望博客我会整理一些自己目前在学的东西，一方面能够让自己复习，一方面也能记录一下学习的过程，也希望能够让有兴趣的小伙伴能够看到，也是一个共同进步的过程。 关于博主我真的是一个很懒很懒的人，平时最喜欢干的事情就是睡觉。希望通过写博客来提高提高自己的学习积极性。 “人间失格”听上去真的很非主流，我自己也这么觉得。但是取名字我觉得更加麻烦，《人间失格》是太宰治的一本书，索性就直接引用过来了。 最后拿《人间失格》里的一句话作结吧 如今的我，谈不上幸福，也谈不上不幸。 一切都会过去的。 在所谓的“人世间”摸爬滚打至今， 我唯一愿意视为真理的，就只有这一句话， 一切都会过去的！ ​ ————太宰治《人间失格》 感谢你看到了最后！","categories":[{"name":"简介","slug":"简介","permalink":"https://heekaai.github.io/categories/%E7%AE%80%E4%BB%8B/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://heekaai.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"HeeKaai"},{"title":"Hello World","slug":"hello-world","date":"2022-01-02T12:28:30.418Z","updated":"2022-01-02T15:36:49.102Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://heekaai.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"},{"name":"C语言","slug":"C语言","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"算法笔记","slug":"C语言/算法笔记","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"C语言/算法笔记/基础","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80/"},{"name":"简介","slug":"简介","permalink":"https://heekaai.github.io/categories/%E7%AE%80%E4%BB%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"},{"name":"C","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"学习","slug":"学习","permalink":"https://heekaai.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"基础算法","slug":"基础算法","permalink":"https://heekaai.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"生活","slug":"生活","permalink":"https://heekaai.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}