{"meta":{"title":"人间失格","subtitle":"人间失格の博客","description":"本科 | 计算机科学与技术 | 算法笔记","author":"HeeKaai","url":"https://heekaai.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.398Z","comments":true,"path":"404.html","permalink":"https://heekaai.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-01-02T12:43:43.492Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://heekaai.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/index.html","permalink":"https://heekaai.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2022-01-02T12:43:43.492Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://heekaai.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"about/index.html","permalink":"https://heekaai.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"archives/index.html","permalink":"https://heekaai.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"census/index.html","permalink":"https://heekaai.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T14:48:55.758Z","comments":true,"path":"contact/index.html","permalink":"https://heekaai.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 人间失格の友链信息 博客名称: 人间失格の博客 博客网址: https://heekaai.github.io 博客头像: https://s4.ax1x.com/2022/01/02/TTxWtK.jpg 博客介绍: 接受平凡，努力出众"},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"categories/index.html","permalink":"https://heekaai.github.io/categories/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"resource/index.html","permalink":"https://heekaai.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"tags/index.html","permalink":"https://heekaai.github.io/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"friends/index.html","permalink":"https://heekaai.github.io/friends/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/index.html","permalink":"https://heekaai.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/movies/index.html","permalink":"https://heekaai.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/music/index.html","permalink":"https://heekaai.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/tools/index.html","permalink":"https://heekaai.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://heekaai.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://heekaai.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://heekaai.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://heekaai.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""}],"posts":[{"title":"矩阵快速幂","slug":"矩阵快速幂","date":"2022-04-16T07:51:58.000Z","updated":"2022-04-16T16:20:57.394Z","comments":true,"path":"posts/008.html","link":"","permalink":"https://heekaai.github.io/posts/008.html","excerpt":"","text":"引入在讲矩阵快速幂的时候，不可避免的需要提及的就是矩阵的运算和快速幂的运用，矩阵快速幂就是把这两者的思想相结合罢了。 矩阵的运算当然数学原理需要用到线性代数的知识，在此不做赘述，不熟悉矩阵乘法的数学原理的话可以自行去百度。 代码： // 矩阵乘法（默认为方阵） #define mst(a) memset(a,0,sizeof(a)) const int maxn = 107; void matrix_mul(int a[][maxn], int b[][maxn], int n) { mst(temp); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++){ temp[i][j] = temp[i][j] + (a[i][k] * b[k][j]); } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = temp[i][j]; return; } 快速幂在这篇博客中提到过快速幂的模板：点击跳转 这里直接放模板，就不再讲原理了： typedef long long ll; const int mod = 1000000007; ll ksm(ll base, ll power, ll mod) { ll res = 1; while (power) { if (power % 2) { res *= base; res %= mod; } power /= 2; base *= base; base %= mod; } return res; } 矩阵快速幂有了引入部分的基础，矩阵快速幂的实现就非常简单了。和快速幂区别只是把底数换成了矩阵罢了。 代码实现： #define mst(a) memset(a,0,sizeof(a)) const int mod = 1000000007; const int maxn = 1007; ll temp[maxn][maxn]{}; ll res[maxn][maxn]{}; void matrix_mul(ll a[][maxn], ll b[][maxn], ll n) { mst(temp); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++){ temp[i][j] = temp[i][j] + (a[i][k] * b[k][j]); temp[i][j] %= mod; } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = temp[i][j]; return; } void matrix_ksm(ll a[][maxn], ll power, ll n) { mst(res); for (int i = 1; i &lt;= n; i++) res[i][i] = 1; while (power) { if (power &amp; 1) { matrix_mul(res, a, n); } power /= 2; matrix_mul(a, a, n); } } 模板题：矩阵快速幂模板 应用1、原题链接 题目给出了递推式：$f_i=f_{i-1}+f_{i+1}$ ,对递推式稍加变形也即：$f_i=f_{i-1}-f_{i-2}$ （本题可以由递推式得到循环节，从而通过循环节来解决该问题，但我们关注的是其利用矩阵快速幂进行解题） 推导： 有了如上的推导式，再利用上面提到的矩阵快速幂的思想，就能够轻松的AC此题了。 代码实现如下： #include&lt;bits/stdc++.h&gt; using namespace std; #define FI freopen(\"in.txt\", \"r\", stdin) #define FO freopen(\"out.txt\", \"w\", stdout) #define mst(a) memset(a,0,sizeof(a)) typedef long long ll; typedef pair&lt;int, int&gt; pii; const int INF = 0x3f3f3f3f; const int mod = 1000000007; const int maxn = 107; const double eps = 1e-11; ll temp[maxn][maxn]{}; ll res[maxn][maxn]{}; void matrix_mul(ll a[][maxn], ll b[][maxn], ll n) { mst(temp); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++){ temp[i][j] = temp[i][j] + (a[i][k] * b[k][j]); temp[i][j] %= mod; } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = temp[i][j]; return; } void matrix_ksm(ll a[][maxn], ll power, ll n) { mst(res); for (int i = 1; i &lt;= n; i++) res[i][i] = 1; while (power) { if (power &amp; 1) { matrix_mul(res, a, n); } power /= 2; matrix_mul(a, a, n); } } int main() { std::ios::sync_with_stdio(false); std::cin.tie(0); ll x, y, k; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; if (k &lt;= 2) { if (k == 1) cout &lt;&lt; (x + mod) % mod &lt;&lt; endl; else cout &lt;&lt; (y + mod) % mod &lt;&lt; endl; return 0; } ll a[maxn][maxn]{}; a[1][1] = a[1][2] = 1; a[2][1] = -1; a[2][2] = 0; matrix_ksm(a, (k - 2), 2); ll ans = y * res[1][1] + x * res[2][1]; cout &lt;&lt; (ans + mod*2) % mod &lt;&lt; endl; return 0; }","categories":[{"name":"快速幂","slug":"快速幂","permalink":"https://heekaai.github.io/categories/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"矩阵的计算","slug":"快速幂/矩阵的计算","permalink":"https://heekaai.github.io/categories/%E5%BF%AB%E9%80%9F%E5%B9%82/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"模板","slug":"模板","permalink":"https://heekaai.github.io/tags/%E6%A8%A1%E6%9D%BF/"}],"author":"HeeKaai"},{"title":"图--最小生成树问题","slug":"图-最小生成树","date":"2022-04-05T12:09:59.000Z","updated":"2022-04-05T14:31:29.459Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://heekaai.github.io/posts/7.html","excerpt":"","text":"前提引入： 最小生成树：图G的生成子图中包含G中所有顶点，并且所有顶点是连通的，而且边权之和最小。 最小生成树是一棵树（边数比顶点数少一的连通图），导出该最小生成树的图应该为无向图。 对于同一个图而言，最小生成树不一定唯一，但其边权之和一定是唯一的。 下面介绍的是求解最小生成树的两种最经典的算法：prim算法和kruskal算法，都是利用贪心的基本算法原理来实现最小生成树的生成。 [TOC] prim算法prim算法读作普利姆算法。 如果有Dijkstra算法的基础的话，prim算法的思想就能够轻松的理解了（思路大同小异）。prim算法实现的基本思路如下： （1）使用一个bool型的数组vis，其下标 i 用来表示顶点 i 是否已经被访问过。 （2）保证依次访问的顶点是连通的（也一定是连通的），不妨令这个连通块为S，再使用一个 int 型的数组d，用该数组来存放尚未到达的顶点离当前连通块S的最小距离。 （3）从根节点（题目给出或任取一点而一般默认选取字典序最小的）出发依次访问离连通块距离最小的顶点u，并将u加入连通块，且不断优化数组 d 存放的值。 看完prim算法的思路是不是觉得和Dijkstra算法特别像（细细品味一下它们之间的联系与区别）。 其实也就只有 d 数组的含义不同罢了，可以参考两个算法的代码进行参照，可以更加清楚直观的看到差别。 代码实现： （朴素的邻接表版本） const int INF = 0x3f3f3f3f; const int maxn = 3007; struct edge { int to, val; edge(int a, int b) :to(a), val(b) {}; }; vector&lt;edge&gt;G[maxn]; int n, d[maxn]; // n-&gt;顶点数 bool vis[maxn]{}; // 默认0为根节点,根据题目调整 int prim() { fill(d, d + maxn, INF); d[0] = 0; int ans = 0; for (int i = 0; i &lt; n; i++) { int u = -1, miin = INF; for (int j = 0; j &lt; n; j++) { if (!vis[j] &amp;&amp; d[j] &lt; miin) { u = j; miin = d[j]; } } if (u == -1)return -1; //不连通 vis[u] = 1; ans += d[u]; for (int j = 0; j &lt; G[u].size(); j++) { int v = G[u][j].to, val = G[u][j].val; if (!vis[v] &amp;&amp; val &lt; d[v]) d[v] = val; } } return ans; } 同样的也能够通过堆来对时间复杂度进行优化。 代码实现：（堆+邻接表） typedef pair&lt;int, int&gt; pii; const int INF = 0x3f3f3f3f; const int maxn = 3007; struct edge { int to, val; edge(int a, int b) :to(a), val(b) {}; }; vector&lt;edge&gt;G[maxn]; int n, d[maxn]; bool vis[maxn]{}; int prim(int s) { priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt;pq; fill(d, d + maxn, INF); int ans = 0; d[s] = 0; pii p(d[s], s); pq.push(p); while (!pq.empty()) { p = pq.top(); pq.pop(); int u = p.second; if (vis[u])continue; vis[u] = 1; ans += d[u]; for (int j = 0; j &lt; G[u].size(); j++) { int v = G[u][j].to, val = G[u][j].val; if (!vis[v] &amp;&amp; d[v] &gt; val) { d[v] = val; pq.push(pii(val, v)); } } } return ans; } 模板题链接 上面的代码已经给出了核心部分，做此类题一定要注意数据范围。 kruskal算法kruskal算法读作克鲁斯卡尔算法。 kruskal算法采用对边的选取进行贪心策略（树一定是选取顶点数-1条边），所以每次选择相对最优的边（满足条件的边中权值最小的），这里的条件是指保证生成的是一棵树。 所以看起来kruskal算法的思想相对而言更加简单易懂。 算法实现过程： （1）初始时，每个结点自成一个连通块。 （2）对所有的边从小到大进行排序。 （3）每次选取最小的那条边，如果这条边连接的两个顶点所在的连通块是不同的，就选择这条边，并将两个连通块连通起来。 （4）当选取的边达到顶点数-1时，跳出；如果遍历完所有的边，选择的边不足顶点数-1，则可以说明此图是不连通的。 那么如何实现判断两个结点所在的连通块是否连通呢？无疑，并查集是最佳选择。 并查集的使用可以参看之前的博客 并查集的查找功能通过查找两个结点的根节点是否相同实现判断两个结点所在的连通块是否连通，并查集的合并功能则可以将不同的连通块进行合并。 有了上面介绍的基础，就可以轻松的把代码写出来了。 代码实现如下： const int INF = 0x3f3f3f3f; const int maxn = 3007; struct edge { int u, v; int w; edge(int a, int b, int c) :u(a), v(b), w(c) {}; }; vector&lt;edge&gt;E; int father[maxn]{}; int n, m; //顶点数和边数 int find_root(int x) { if (x == father[x]) return x; else { int F = find_root(father[x]); father[x] = F; return F; } } bool cmp(edge a, edge b) { return a.w &lt; b.w; } int kruskal() { for (int i = 1; i &lt;= n; i++) father[i] = i; sort(E.begin(), E.begin() + m, cmp); int ans = 0, cnt = 0; //边权之和当前已经选取了的边数 for (int i = 0; i &lt; m; i++) { int u = E[i].u, v = E[i].v; int Fu = find_root(u), Fv = find_root(v); if (Fu != Fv) { father[Fu] = Fv; ans += E[i].w; cnt++; } if (cnt == n - 1)break; } if (cnt &lt; n - 1)return -1; else return ans; } 对比一下两种算法： kruskal算法时间复杂度主要花销在对边进行排序上，如果在边比较少而点比较多的情况下，优先考虑采用kruskal算法；相对应的，如果在边比较多而点相对少的情况下，优先考虑采用prim算法。 END","categories":[{"name":"算法","slug":"算法","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"最小生成树","slug":"算法/最小生成树","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"图论","slug":"图论","permalink":"https://heekaai.github.io/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"HeeKaai"},{"title":"图--最短路径问题","slug":"图-最短路径问题","date":"2022-03-22T02:26:19.000Z","updated":"2022-04-05T12:14:17.204Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://heekaai.github.io/posts/6.html","excerpt":"","text":"[TOC] Dijkstra算法Dijkstra算法可以读作迪杰斯特拉算法。 Dijkstra算法用来解决单源最短路问题（划重点），也即：给定图和一个起点（源点），求解从源点到达其它顶点的最短路径。 具体实现： （1）用一个bool型的数组来区分表示某个顶点是否已经访问过了，用一个数组记录源点到各顶点的最短距离并初始化（为INF），然后执行（2）-（3）步骤n次（一共n个顶点）。 （2）每次从未访问过的顶点中，选择一个与源点距离最短的一个顶点（记作u），访问该顶点。 （3）令该顶点u为中介点，优化源点与所有从顶点u出发能到达的顶点v之间的最短距离。 代码实现（未优化的原始版本）（用邻接矩阵储存图） const int INF = 0x3f3f3f3f; const int maxn = 107; int n, d[maxn]{}; int G[maxn][maxn]{}; bool vis[maxn]{}; void Dijkstra(int s) //s为源点 { memset(vis, false, sizeof(vis)); //初始化 fill(d, d + maxn, INF); d[s] = 0; for (int i = 0; i &lt; n; i++) { int u = -1, MIN = INF; //寻找最小距离的顶点u for (int j = 0; j &lt; n; j++) { if (!vis[j] &amp;&amp; d[j] &lt; MIN) { u = j; MIN = d[j]; } } if (u == -1)return; //剩下的点和顶点不连通 vis[u] = true; for (int v = 0; v &lt; n; v++) //u作为中介点优化最短距离 //如果使用的是邻接表储存只有这句话需要改动 { if (!vis[v] &amp;&amp; G[u][v] != INF) { if (d[u] + G[u][v] &lt; d[v]) d[v] = d[u] + G[u][v]; } } } } 上面的代码一个很好理解，就是把提到的具体实现改写成了代码。 再来看看复杂度，明显达到了O（2*n^2）的级别。那么考虑如何优化代码，将时间复杂度降低下来。 显然，最外面的for循环来标记每一个顶点已被访问是必不可少的，寻找最小距离的顶点u是可以优化的，通常使用堆优化来降低时间复杂度。最简洁的方法自然是采用STL中的容器priority_queue来实现（每次弹出的元素一定是整个队列中最小的元素）。 堆优化代码：（使用邻接表储存图进一步优化时间复杂度） （在n的数量级&gt;=1e5时必须采用这种堆优化+邻接表方式 ） typedef pair&lt;int, int&gt; pii; const int INF = 0x3f3f3f3f; const int maxn = 107; struct edge { int to; int val; }; int n, d[maxn]{}; vector&lt;edge&gt;G[maxn]; bool vis[maxn]{}; void Dijkstra(int s) { priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt;pq; memset(vis, 0, sizeof(vis)); fill(d, d + maxn, INF); d[s]=0; pii p; p.first = 0; p.second = s; pq.push(p); while (!pq.empty()) { p = pq.top(); pq.pop(); int u = p.second; if (vis[u])continue; vis[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i].to; if (d[v] &gt; d[u] + G[u][i].val) { d[v] = d[u] + G[u][i].val; pq.push(pii(d[v], v)); } } } } 细细感受一下朴素算法和堆优化算法的区别，本质上其实是一模一样的。 特别注意：Dijkstra算法只能应对所有边权都是非负的情况！ 上面提到的都是最短距离的求解，下面将提到如何求解最短的路径。 很显然，要得到最短路径，终点和起点是已知的，缺少的自然是中间的结点，要得到这些中间结点，自然而然会选择在以u为中介优化的部分来做文章。所以我们可以用一个数组pre来记录前驱结点的编号，在优化的时候赋值即可。 代码实现也非常简单 const int INF = 0x3f3f3f3f; const int maxn = 107; int n, d[maxn]{}; int G[maxn][maxn]{}; bool vis[maxn]{}; int pre[maxn]{}; void Dijkstra(int s) { memset(vis, false, sizeof(vis)); fill(d, d + maxn, INF); d[s] = 0; for (int i = 0; i &lt; n; i++) { int u = -1, MIN = INF; for (int j = 0; j &lt; n; j++) { if (!vis[j] &amp;&amp; d[j] &lt; MIN) { u = j; MIN = d[j]; } } if (u == -1)return; vis[u] = true; for (int v = 0; v &lt; n; v++) { if (!vis[v] &amp;&amp; G[u][v] != INF) { if (d[u] + G[u][v] &lt; d[v]) { d[v] = d[u] + G[u][v]; pre[v]=u; } } } } } 得到前驱数组pre后，利用dfs（在这里也就是递归的方法）来实现路径的输出。 代码非常简单： int pre[maxn]{}; void dfs(int s, int u) { if (u == s) //边界 { cout &lt;&lt; s; return; } dfs(s, pre[u]); cout &lt;&lt; u; //从最深处回来的时候输出路径上的结点 } 至此，Dijkstra算法的核心部分内容就差不多结束了，但是题目考查形式绝对不会赤裸裸，一定要注意其变化（通常会加上第二标度），但抽丝剥茧后，一定都有一个共同点：单源！！！ 例题： 原题链接 题意：（中文题面很好理解）n个顶点，m条无向边，每个点的点权已知。给出起点和终点，求从起点到终点是最短路径条数及最短路径上的最大点权和。 思路：这题除了求解最短路径和最短距离外还要求求解最短路径条数和最大点权和，则在上面的代码中需要添加额外的信息来记录这两个量。w数组记录起点到其他点的最大点权之和；num数组记录起点到其他点的最短路径条数。n的范围在0-500，所以可以采用邻接矩阵的方式来存储图。 AC代码：（该题包括上面提及的所有内容，综合考查Dijkstra算法） #include&lt;bits/stdc++.h&gt; using namespace std; #define FI freopen(\"in.txt\", \"r\", stdin) #define FO freopen(\"out.txt\", \"w\", stdout) typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef list&lt;int&gt;::iterator lii; typedef vector&lt;int&gt;::iterator vii; const int INF = 0x3f3f3f3f; const int mod = 998244353; const int maxn = 507; int miin = INF, maax = -1; int n, m, s, d; int G[maxn][maxn]{}; int w[maxn]{}, max_w[maxn]{}; int num[maxn]{}, pre[maxn]{}; bool vis[maxn]{}; int D[maxn]{}; void Dij() { memset(vis, 0, sizeof(vis)); memset(max_w, 0, sizeof(max_w)); memset(num, 0, sizeof(num)); fill(D, D + maxn, INF); D[s] = 0; max_w[s] = w[s]; num[s] = 1; for (int i = 0; i &lt; n; i++) { int u = -1, MIN = INF; for (int j = 0; j &lt; n; j++) { if (!vis[j] &amp;&amp; D[j] &lt; MIN) { u = j; MIN = D[j]; } } if (u == -1)return; vis[u] = 1; for (int v = 0; v &lt; n; v++) { if (!vis[v] &amp;&amp; G[u][v] != INF) { if (G[u][v] + D[u] &lt; D[v]) { D[v] = D[u] + G[u][v]; pre[v] = u; num[v] = num[u]; max_w[v] = max_w[u] + w[v]; } else if (G[u][v] + D[u] == D[v]) { if (max_w[u] + w[v] &gt; max_w[v]) { max_w[v] = max_w[u] + w[v]; pre[v] = u; } num[v] += num[u]; } } } } } void dfs(int x) { if (x == s) { cout &lt;&lt; s &lt;&lt; \" \"; return; } dfs(pre[x]); if (x != d) cout &lt;&lt; x &lt;&lt; \" \"; else cout &lt;&lt; x &lt;&lt; endl; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; for (int i = 0; i &lt; n; i++) cin &gt;&gt; w[i]; fill(G[0], G[0] + maxn * maxn, INF); for (int i = 0; i &lt; m; i++) { int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; G[x][y] = z; G[y][x] = z; } Dij(); cout &lt;&lt; num[d] &lt;&lt; \" \" &lt;&lt; max_w[d] &lt;&lt; endl; dfs(d); return 0; } Bellman-Ford算法Bellman-Ford算法，简称BF算法，上面提到的Dijkstra算法可以很好的解决无负权图的单源最短路径问题，但是权值中一旦出现负值Dijkstra算法就会出现问题（因为无法保证当前选取的路径是最短的）。而BF算法则无论权值正负与否都能够很的求解。 BF算法的主要思想：对图G中的每一条边都进行v-1轮操作，每一轮都要遍历图G中的所有的边；不妨记每次枚举的边为u-&gt;v，如果以u为中介点能够使得$d[v]$更小，就不断优化。这时算法的时间复杂度为O（VE）。因为边权可能是负值，所以可能会存在源点可到达的负环（环指的是经过若干个顶点后回到该点），此时的$d[v]$不是最小的（不断走这个环就会一直小下去），否则即为最小的，不能够再进行优化。 因为需要遍历枚举每一条边，如果使用邻接矩阵显然不是非常合理，所以在这里我们会选择使用邻接表来对图进行存储。 代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; const int INF = 0x3f3f3f3f; const int maxn = 107; struct edge { int to; int val; }; vector&lt;edge&gt;vec[maxn]; int n, d[maxn]; //顶点数和最小的距离 bool BF(int s) { fill(d, d + maxn, INF); d[s] = 0; for (int i = 0; i &lt; n - 1; i++) { //进行n-1轮操作一定能够最优（有严格证明） for (int u = 1; u &lt;= n; u++) { //枚举每一条边 for (int j = 0; j &lt; vec[u].size(); j++) { int v = vec[u][j].to; int val = vec[u][j].val; if (d[u] + val &lt; d[v]) { d[v] = d[u] + val; } } } } //判断是否存在负环 for (int u = 0; u &lt; n; u++) { //枚举每一条边 for (int j = 0; j &lt; vec[u].size(); j++) { int v = vec[u][j].to; int val = vec[u][j].val; if (d[u] + val &lt; d[v])return false; } } return true; } int main () { int m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 0; i &lt; m; i++) { int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; edge e; e.to = y; e.val = w; vec[x].push_back(e); } BF(s); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; d[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return 0; } 代码非常简单，很好看懂。唯一要注意的是最短路径的输出，由于BF算法的特性，某一结点可能会反复经过，所以之前提到的pre数组记录的方法在这里显然不可行，为了解决这个问题我们可以用集合（set）代替原来的数组即可。代码实现不再呈现，后面的SPFA算法中可以看到如何使用set来记录前驱结点。 虽然BF算法实现起来非常简洁，但是时间复杂度却不够理想。其实，每次枚举所有的边其中大部分的枚举都是无意义的枚举，占用了不必要的时间复杂度。所以：只有当某个顶点u的$d[u]$值改变时，从他出发的边的邻接点（v）的$d[v]$的值才有可能发生改变。我们因此可以通过队列来实现优化。 而优化的算法也就叫作SPFA算法，具体实现可以看后文。 SPFA算法（BF算法的优化进阶版） 具体优化方法：建立一个队列，每次将对首顶点u取出，从u出发遍历去优化他的所有邻接结点，并且把u能够优化的结点加入队列（注意判断，不能重复添加）。跳出条件：队列为空或者某个顶点入队次数超过了v-1次。 时间复杂度方面：O（k*E）k是个变量，大部分的样例处理都会非常高效（甚至优于堆优化后的Dijkstra算法），但是如果存在负环，时间复杂度就和优化前的BF算法。 代码实现： #include&lt;bits/stdc++.h&gt; using namespace std; const int INF = (1 &lt;&lt; 31) - 1; const int maxn = 10007; struct edge { int to, val; edge(int a, int b): to(a), val(b) {}; }; vector&lt;edge&gt;G[maxn]; int n, d[maxn], num[maxn]; //num数组用来统计入队次数，如果确定不会有负环，则无需使用 bool inq[maxn]; bool SPFA(int s) { memset(inq, false, sizeof(inq)); memset(num, 0, sizeof(num)); fill(d, d + maxn, INF); d[s] = 0; queue&lt;int&gt;q; q.push(s); inq[s] = 1; num[s]++; while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int j = 0; j &lt; G[u].size(); j++) { int v = G[u][j].to; int val = G[u][j].val; if (d[u] + val &lt; d[v]) { d[v] = d[u] + val; if (!inq[v]) { q.push(v); inq[v] = true; num[v]++; if (num[v] &gt;= n)return false; } } } } return true; } int main () { int m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 0; i &lt; m; i++) { int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; edge e(y, w); G[x].push_back(e); } SPFA(s); for (int i = 1; i &lt;= n; i++) { if (i != n) cout &lt;&lt; d[i] &lt;&lt; \" \"; else cout &lt;&lt; d[i] &lt;&lt; endl; } cout &lt;&lt; endl; return 0; } SPFA算法是非常灵活的，其内部的写法可以根据不同的背景来不断变化，这里写出来的只是SPFA的一个基础版本而已，所以要想深刻掌握这一算法，一定要多做不同类型的最短路径问题的练习。 最后，针对上面三种题目，放两个板子题： 弱化版 强化版 因为纯纯模板题，所以这里就不放代码了，把上面给出的代码自己码一码。 Floyd算法Floyd算法读作弗洛伊德算法。 Floyd算法用来解决全源最短路问题，也即求解给定图中任意两点之间的最短路问题，时间复杂度是O（n^3）的级别。所以顶点数通常在200以内才会选择Floyd算法，因为顶点数不多，所以通常使用邻接矩阵来实现Floyd算法。 有类似于Dijkstra算法的基础，同样的道理，可以借助第三点k点作为中介点来对u、v两点之间的距离进行一个优化，非常好理解，所以我们通过枚举中介点1-n（n为图的顶点数）来进行全源最短路的优化。 代码非常好写： #include&lt;bits/stdc++.h&gt; using namespace std; const int INF = 0x3f3f3f3f; const int maxn = 107 int n, m; int d[maxn][maxn]{}; int pre[maxn][maxn]{}; void Floyd() { for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (d[i][k] != INF &amp;&amp; d[k][j] != INF) { if (d[i][k] + d[k][j] &lt; d[i][j]) { d[i][j] = d[i][k] + d[k][j]; pre[i][j] = k; } } } } } } int main() { std::ios::sync_with_stdio(false); std::cin.tie(0); fill(d[0], d[0] + maxn * maxn, INF); cin &gt;&gt; n &gt;&gt; m;//顶点数与边数 for (int i = 1; i &lt; n; i++) d[i][i] = 0; for (int i = 0; i &lt; m; i++) { int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; d[x][y] = w; } return 0; } 注意使用Floyd算法的条件是顶点数在200以内，因为算法的时间复杂度为O（n^3）,对于顶点数过多的题目，则不宜使用Floyd算法进行求解。 END","categories":[{"name":"算法","slug":"算法","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"最短路径","slug":"算法/最短路径","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"图论","slug":"图论","permalink":"https://heekaai.github.io/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"HeeKaai"},{"title":"并查集","slug":"并查集","date":"2022-03-12T07:12:31.911Z","updated":"2022-03-22T02:28:27.009Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://heekaai.github.io/posts/5.html","excerpt":"","text":"定义并查集是一种维护集合的数据结构，用以解决动态连通性问题。顾名思义，“并”—“合并”—“Union”；“查”—“查找”—“Find”；“集”—“集合”—“Set”。主要需要支持查找和合并两个操作。 通常而言，并查集使用一个数组来实现： int father[N]; 数组含义如下： $father[i]$表示元素 i 的父亲结点，其父亲结点也一定是这个集合里的元素。特别的，如果$father[i]=i$,则说明元素i是该集合的根节点，且对同一个集合只存在一个根节点，所以根节点也是这个集合的一个重要标识。 基本操作的实现初始化int father[N]{}; void init() { for(int i=1;i&lt;N;i++) father[i]=i; } 初始化每一个元素都是根节点，独立成一个元素。 查找通过递归实现 int find_root(int x){ if(x==father[x])return x; else return find_root((father[x])); } 合并合并是指把两个集合合并成一个集合，只有两个集合是不同集合时，才能够合并。合并的过程是把一个集合的根节点的父亲指向另一个集合的根节点。 void Union(int a,int b){ int faA=find_root(a); int faB=find_root(b); if(faA==faB)return; father[faB]=faA; //father[faA]=faB也是可以的 } 特别注意： 一定是根节点和根节点的互相指向关系。 不能对同一个集合的元素进行合并操作，否则将会产生一个闭环，从而破坏了其本身作为“树”的结构。 路径压缩上面并合集的基本操作都非常简单，所以不做过多解释。现在考虑一个问题：对于一个链型的数据集合，要查找链条中的最后一个元素的父亲根结点，时间复杂度达到了O（N），这显然是无法接受的。所以我们应该想办法将其优化。 这样处理之后，每一个子元素的查询时间复杂度是不是就可以降至O（1）。 现在，只需要把这样的处理改写成代码即可。 还是递归的写法： int find_root(int x){ if(x==father[x])return x; else{ int F=find_root(father[x]); //寻找到根结点 father[x]=F; return F; } } 在寻找的时候，实现了路径上的元素的路径压缩。 例题放上一道例题（并查集的裸题）： Learning Languages 题目描述： 一个公司有n个员工，会使用m种语言，给出每个人会使用的语言（可以一种都不会），每个人学习不会的语言会花费1个单位的钱，为了让任意两个员工都能够交流（其他员工可以当他们的翻译），现在要求求出最小花费。 思路： 并查集的思路，最后数出有多少根节点即可。（详细的结合代码理解） AC代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 107; int t, n, m; int num[maxn]{}; /*num[i]的含义：第i种语言，员工num[i]第一个掌握（输入顺序的第一），后面出现 会这种语言的自然是他的子节点*/ int father[maxn]{}; void init() { for (int i = 0; i &lt; maxn; i++) father[i] = i; } int find_root(int x) { if (x == father[x])return x; else return find_root((father[x])); } void _union(int a, int b) { int faA = find_root(a); int faB = find_root(b); if (faA == faB)return; father[faB] = faA; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(0); cin &gt;&gt; n &gt;&gt; m; int ans = 0; memset(num, 0, sizeof(num)); init(); for (int i = 1; i &lt;= n; i++) { int t; cin &gt;&gt; t; while (t--) { int x; cin &gt;&gt; x; if (num[x] == 0)num[x] = i; else { if (i == father[i]) { father[i] = num[x]; }else{ int F1 = find_root(i); int F2 = num[x]; _union(F1, F2); //该员工当翻译，合并两个集合 } } } } bool all0 = 1; for (int i = 1; i &lt;= m; i++) { if (num[i] != 0) { all0 = 0; break; } } if (all0) { cout &lt;&lt; n &lt;&lt; endl; return 0; } for (int i = 1; i &lt;= n; i++) { if (i == father[i])ans++; } ans--; cout &lt;&lt; ans &lt;&lt; endl; return 0; } 运用的函数都是上文提到过的，此题查找部分不需要压缩路径（数据范围很小），特别注意最后的all0的特判（没有人会公司的官方语言）。 END","categories":[{"name":"算法","slug":"算法","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"动态连通性问题","slug":"算法/数据结构/动态连通性问题","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://heekaai.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"HeeKaai"},{"title":"扩展欧几里得算法和中国剩余定理","slug":"扩展欧几里得算法和中国剩余定理","date":"2022-03-08T11:44:14.111Z","updated":"2022-03-12T09:26:28.326Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://heekaai.github.io/posts/4.html","excerpt":"","text":"[TOC] 扩展欧几里得算法扩展欧几里得算法就是对ax+by=gcd（a，b）的求解 问题引入：给定两个整数a和b，求一组解（x，y）使得等式ax+by=gcd（a，b）成立。（解一定存在的，有定理证明过） 回顾一下欧几里得算法（辗转相除法） int gcd(int a,int b){ if(b==0)return a; else return gcd(b,a%b); } （为了不弄混淆，记g=gcd（a，b），这里的a和b是最初的值） 观察跳出函数时的情况，a=g，b=0；此时x=1，y=0则是方程的解。按照这样的思路，是不是只要反推就可以得到最初的x，y的值。 下面是得到递推式的推导过程 现在有了递推边界和递推式，就可以得到求解的代码： int ex_gcd(int a, int b, int&amp; x, int&amp; y) //利用引用，直接修改x、y的值 { if (b == 0) //递归边界 { x = 1; y = 0; return a; //a=g } int g = ex_gcd(b, a % b, x, y); int temp = x; x = y; y = temp - a / b * y; return g; } 纯净版： int ex_gcd(int a, int b, int&amp; x, int&amp; y) { if (b == 0) { x = 1; y = 0; return a; } int g = ex_gcd(b, a % b, x, y); int temp = x; x = y; y = temp - a / b * y; return g; } 符号和上述推导一致，应该很容易看明白。由于x，y是引用，故函数结束时x，y的值就是一组解；得到一组解就很容易将其推广到无数组解： 扩展欧几里得算法的应用： ax+by=c的求解 同余式的求解 逆元的求解 中国剩余定理（CRT）问题引入：已知一个数除以3余2，除以5余3，除以7余2，求解这个数。（孙子问题的白话版） \\begin{cases} n1=k1*3+2\\\\ n2=k2*5+3\\\\ n3=k3*7+2\\\\ x=n1+n2+n3 \\end{cases} n1除以3余2，且是5,7的公倍数 ==》n1=35 n1除以5余3，且是3,7的公倍数 ==》n1=63 n1除以7余2，且是3,5的公倍数 ==》n1=30 则x=（35+63+30）= 128 x_{min}=x_{now}\\%gcd(3,5,7)=128\\%105=23这就是著名的的孙子问题。我们再来看中国剩余定理的定义： 设正整数$m1,m2,······,mk$ 两两互素，则同余方程组： \\begin{cases} x\\equiv a_{1}(mod\\ m_{1})\\\\ x\\equiv a_{2}(mod\\ m_{2})\\\\ ······\\\\ x\\equiv a_{k}(mod\\ m_{k})\\\\ \\end{cases}一定会有整数解，并且在模M（$M=\\prod_{i=1}^{m}m_i$）下的解是惟一的，x的值为： x\\equiv (a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+···+a_kM_kM_k^{-1})\\ mod\\ M其中$M_i={M\\over m_i}$ ,而$M_i^{-1}为M_i模m_i的逆元$ 上面就是中国剩余定理的完整描述，也就可以得到下面的代码模板了： //情况一：n个数互质 const int maxn = 2007 ; int a[maxn], m[maxn], n; int CRT() { int M = 1; for (int i = 0; i &lt; n; i++) M *= m[i]; int ret = 0; for (int i = 0; i &lt; n; i++) { int x, y; int tm = M / m[i]; ex_gcd(tm, m[i], x, y); ret = (ret + tm * x * a[i]) % M; } return (ret + M) % M; } 现在把情况更加一般化，如果n个数不互质呢，其实也是可以转化的，（证明省略），直接上代码： //情况二：n个数不互质 int a[maxn], m[maxn], n; int CRT() { if (n == 1) { if (m[0] &gt; a[0])return a[0]; else return -1; } int x, y, d; for (int i = 1; i &lt; n; i++) { if (m[i] &lt;= a[i])return -1; d = ex_gcd(m[0], m[i], x, y); if ((a[i] - a[0]) % d != 0)return -1; int t = m[i] / d; x = ((a[i] - a[0]) / d * x % t + t) % t; a[0] = x * m[0] + a[0]; m[0] = m[0] * m[i] / d; a[0] = (a[0] % m[0] + m[0]) % m[0]; } return a[0]; } END","categories":[{"name":"算法","slug":"算法","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"基础","slug":"算法/基础","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/"},{"name":"CRT模板","slug":"算法/基础/CRT模板","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/"},{"name":"扩展欧几里得","slug":"算法/基础/CRT模板/扩展欧几里得","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"模板","slug":"模板","permalink":"https://heekaai.github.io/tags/%E6%A8%A1%E6%9D%BF/"}],"author":"HeeKaai"},{"title":"STL入门--algorithm头文件","slug":"STL入门-algorithm头文件","date":"2022-02-18T02:51:59.312Z","updated":"2022-03-02T08:36:37.022Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://heekaai.github.io/posts/3.html","excerpt":"","text":"[TOC] algorithm头文件下的常用函数前提：添加algorithm头文件 max（）、min（）和abs（）max（x，y）和min（x，y）分别返回x和y中的最大值和最小值，且参数必须是两个（可以是浮点数）。如果想要返回三个数x、y、z的最大值，可以通过max（x，max（y，z））的写法。 abs（x）返回x的绝对值。注意：x必须是整数，浮点型的绝对值请用math头文件下的fabs。 swap（）swap（x，y）用以交换x和y的值 reverse（）reverse（it1，it2）可以将数组指针在[ it1, it2 ）之间的元素或迭代器在[ it1, it2 ）范围内的元素进行反转。（左闭右开的特点）示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt;ve; int num[9]; for (int i = 0; i &lt; 6; i++) { num[i] = i; ve.push_back(i); } vector&lt;int&gt;::iterator it=ve.begin(); reverse(it + 1, it + 4); reverse(num + 1, num + 4); for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; ve[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; num[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; //输出：0 3 2 1 4 5 return 0; } next_permutation（）next_permutation（）给出一个序列在全排列中的下一个序列。 全排列是按照字典序由小至大的顺序进行排序。 并且值得注意的是其返回值，若存在下一个排序，返回值是true；若不存在最后一个排序（即当前为最后一个全排列），返回值则为false。根据这一特性，通常会使用do···while···循环来实现全排列。 下面是1-9全排列的代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main () { int num[9]; for(int i=0;i&lt;9;i++) num[i]=i+1; do{ for(int i=0;i&lt;9;i++) cout&lt;&lt;num[i]&lt;&lt;\" \"; cout&lt;&lt;endl; }while(next_permutation(num,num+9)); return 0; } fill（）fill（）函数可以将数组或容器某区间内所有元素全部赋值为同一值，用法和memset类似，但是fill（）函数的赋值可以是数据范围内的一值。 具体用法： fill(it1,it2,num)； //it可以是指针或者是迭代器 sort（）顾翻译思义，sort就是用来排序的函数，效率较高。相比于C语言中的qsort函数，sort函数用起来更加便捷，并且规避某些效率特别低的情况。 sort函数的三个参数 第一个是要排序的数组的起始地址。 第二个是结束的地址（最后一位要排序的地址）的下一个地址 比较函数 其中第三点非必填内容，若不填，则默认递增的顺序 一定特别需要注意的是：“左闭右开”第二个参数是末尾元素的下一个地址 比较函数cmp的书写cmp函数的书写就好比人为给sort（）函数制定比较规则一样，让sort（）函数按照自己的想法进行排序。 基本数据类型 基本数据类型本身就具有可比性，则默认即为增序。只需记忆递减的情形下的cmp函数。 示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; bool cmp(int a, int b) { return a &gt; b; } int main() { int num[5]{3,8,1,2,4}; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出：3 8 1 2 4 cout &lt;&lt; endl; sort(num, num + 5); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出： 1 2 3 4 8 cout &lt;&lt; endl; sort(num, num + 5, cmp); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出： 8 4 3 2 1 cout &lt;&lt; endl; return 0; } 其他数据类型同理可知。 结构体数组的排序 结构体本身并无直接可比性，所以就没有默认排序一说，都需要通过书写cmp函数来实现人为制定比较规则。 一级排序： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; struct test { int x, y; }ss[5]; bool cmp(test a, test b) { return a.x &lt; b.x;//“&lt;”从小至大 “&gt;”从大至小 } int main() { for (int i = 0; i &lt; 5; i++) { ss[i].x = rand()%17; ss[i].y = rand()%17;//随机数 } for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; ss[i].x &lt;&lt; \" \" &lt;&lt; ss[i].y &lt;&lt; endl; } cout &lt;&lt; endl; sort(ss, ss + 5, cmp); for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; ss[i].x &lt;&lt; \" \" &lt;&lt; ss[i].y &lt;&lt; endl; } return 0; } 很明显可以发现，一级排序仅仅只会排序结构体中的第一个变量，若想实现第二个变量的排序，只需改变cmp函数的写法 bool cmp(test a, test b) { if (a.x != b.x)return a.x &lt; b.x; else return a.y &gt; b.y; }//x从小到大，y从大到小的顺序 类似的可以进行扩展。 STL容器的排序 前提：STL容器中只有vector、string、deque才可以使用sort函数进行排序 用法类似于数组，牢记“左闭右开”的规则。 lower_bound（）和upper_bound（）前提：数组或容器本身是有序的 lower_bound（left，right，num）用来在容器或数组的[left，right）中查找第一个大于或等于num的元素的位置。若为数组，返回指针；若为容器，返回迭代器。 相应的，upper_bound（）函数的作用是查找第一个大于num的元素的位置。 换言之，假设本身数组或容器内不存在该元素，两个函数均返回可以插入该元素的位置。（即若存在，应该在哪个位置） 小技巧：通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 重载前提：针对从大到小排序的数组或容器，利用重载来实现查找 大同小异： lower_bound(left,right,num,greater&lt;type&gt;()); //查找第一个小于或等于num的元素位置 upper_bound(left,right,num,greater&lt;type&gt;()); //查找第一个小于num的元素位置 示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; bool cmp(int a, int b) { return a &gt; b; } int main() { int a[9]{}; for (int i = 0; i &lt; 9; i++) a[i] = rand() % 5 + 1; sort(a, a + 9); for (int i = 0; i &lt; 9; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; int pos1 = lower_bound(a, a + 9, 3) - a; cout &lt;&lt; pos1 &lt;&lt; \" \"; int pos2 = upper_bound(a, a + 9, 3) - a; cout &lt;&lt; pos2 &lt;&lt; endl; sort(a, a + 9, cmp); for (int i = 0; i &lt; 9; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; pos1 = lower_bound(a, a + 9, 3,greater&lt;int&gt;()) - a; cout &lt;&lt; pos1 &lt;&lt; \" \"; pos2 = upper_bound(a, a + 9, 3,greater&lt;int&gt;()) - a; cout &lt;&lt; pos2 &lt;&lt; endl; return 0; } 补充： partial_sumpartial_sum 是C++ STL 算法组件中的其中一个算法，其作用是计算某个序列局部元素的和。它有四个重载函数。要使用 partial_sum 需要引用头文件 numeric。 一般来说，使用partical_sum函数需要四个参数 partial_sum(容器要计算的起始位置，容器要计算的结束位置，结果存放的起始位置，自定义函数) 其中自定义函数可以留白，则默认计算局部和。而且，结果可以存放在原容器内。 示例如下： #include &lt;iostream&gt; #include &lt;numeric&gt; using namespace std; int cmp(int x, int y) { return x - y; } int main () { int test[10]; int ans[10]; for (int i = 0; i &lt; 10; i++) test[i] = rand() % 57; for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; partial_sum(test, test + 10, ans); for (int i = 0; i &lt; 10; i++) cout &lt;&lt; ans[i] &lt;&lt; \" \"; cout &lt;&lt; endl; partial_sum(test, test + 10, test, cmp); for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return 0; } 运行结果如下： 可以很直接看到用法，此函数通常可以用于前缀和，减少代码量。 max_element和min_element作用：返回最大值和最小值的地址 示例如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int main () { int test[10]; for (int i = 0; i &lt; 10; i++) test[i] = rand() % 57; for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; cout &lt;&lt; max_element(test, test + 10) &lt;&lt; endl;//输出地址 cout &lt;&lt; *max_element(test, test + 10) &lt;&lt; endl;//输出元素 cout &lt;&lt; max_element(test, test + 10) - test &lt;&lt; endl;//输出在数组中的位置 return 0; } 运行结果： END","categories":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"}],"author":"HeeKaai"},{"title":"STL入门---容器篇","slug":"STL入门-容器","date":"2022-01-30T13:15:10.000Z","updated":"2022-03-14T06:35:28.185Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://heekaai.github.io/posts/2.html","excerpt":"","text":"[TOC] 写在前面此文介绍STL中的容器部分，仅仅涉及入门知识及一些常见的用法。 vector vector 在英文中翻译为向量，但是在C++中把它叫做“变长数组”，更加容易理解它的用法。顾名思义：vector容器是长度根据需要而自动改变的数组。 如果要使用vector容器，需要在头文件里加上#include&lt; vector &gt; vector的定义讲vector的定义之前，可以先回顾一下数组的定义方法。 typename arrayname[arraysize]; //一维数组 typename arrayname[arraysize1][arraysize2]; //二维数组 下面再来看vector的定义： vector&lt;typename&gt; name; 和一维数组一样，typename可以是所有的基本类型，例如：int、double、char、结构体······当然也可以是STL中的其他容器，例如：vector、set、queue······ vector数组的定义 vector&lt;typename&gt; name[size]; 例如： vector&lt;int&gt; ve[100]; 这样ve[0]到ve[99]每一维都是一个vector容器。 当然，如果我们把typename也改成vector容器，同样可以实现二维数组的功能。 vector&lt;vector&lt;int&gt;&gt; name; 这样数组的两个维度都是“变长”的。而vector\\ name[size]其中一维的长度就已经固定了。稍微体会一下这两者的区别。 访问vector容器中的元素vector容器有两种访问方式：通过下标或者迭代器访问。下面分别讲到这两种访问方式。 通过下标访问 和访问普通的数组一样，对于一个定义为vector&lt;int&gt;ve的vector容器而言，直接访问ve[index]即可。当然这个下标访问和普通数组一样是从0~~ve.size（）-1，也需要注意存在越界的问题。 通过迭代器访问 迭代器（iterator）可以理解为一个类似于指针的东西，其定义为： vector&lt;typename&gt;::iterator it; 这样定义之后 i t 就是vector\\::iterator 型的变量。也即迭代器 i t ，并且可以通过*i t来访问vector中的元素。 比如说： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=0;i&lt;6;i++) ve.push_back(i); //后面会提，在ve的末尾添加元素i for(int i=0;i&lt;6;i++) cout&lt;&lt;ve[i]&lt;&lt;\" \"; cout&lt;&lt;endl; vector&lt;int&gt;::iterator it=ve.begin(); //it指向ve的首地址 for(int i=0;i&lt;6;i++) cout&lt;&lt;*(it+i)&lt;&lt;\" \"; cout&lt;&lt;endl; return 0; } 从上面给出的例程，可以看出ve[i]和*(it+i)是等价的。 上面的代码中出现了ve.begin（），其作用是取到vector容器的首地址。而ve.end（）却不是取到vector容器的末尾地址，而是末尾元素的下一个地址。 另外，需要注意的还有迭代器还支持自加和自减操作，则遍历vector容器还有第三种写法： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=0;i&lt;6;i++) ve.push_back(i); vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; cout&lt;&lt;endl; return 0; } vector容器的常用函数 push_back（） 上面的代码就已经使用过这种方式添加过元素了。很简单，和函数名一样，push_back(x) 的作用就是在 vector 容器最后添加上元素 x ，时间复杂度是 O（1） 。 pop_back（） 有添加作用的函数自然，相对的肯定会有删减作用的函数。pop_back（） 用以删除vector容器中的最后一个元素，时间复杂度同样为 O（1）。 比如说： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it; cout&lt;&lt;\" \"; } putchar('\\n'); ve.pop_back(); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it; cout&lt;&lt;\" \"; } putchar('\\n'); return 0; } size（） size（）函数用以获取vector容器中的元素个数。 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } cout&lt;&lt;ve.size()&lt;&lt;endl; return 0; } clear（） clear（）用以清空vector容器中的所有元素，时间复杂度是 O（N) ，其中N是vector容器中的元素个数。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } cout&lt;&lt;ve.size()&lt;&lt;endl; //输出5 ve.clear(); cout&lt;&lt;ve.size()&lt;&lt;endl; //输出0 return 0; } insert（） insert（it,x）用以向vector容器的任意迭代器it位置插入一个元素x，时间复杂度为 O（N)。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; it=ve.begin()+2; //*** ve.insert(it,-1); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 -1 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } 需要特别说明的是，代码中注释标注为三个的地方，在常用的STL容器中，*只有在string和vector中，才允许使用ve.begin（）+2这种迭代器直接加上整数的写法！ erase（） erase（）也是一种删除函数，它有两种使用方法：删除单个元素以及删除一个区间内的所有元素。时间复杂度自然也是 O（N)。 （1）删除单个元素： erase（it）即删去迭代器 it 处的元素。 例如： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; it=ve.begin()+2; ve.erase(it); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } （2）删除一个区间内的所有元素 遵循着“左闭右开”的原则，erase（left,right）即删去[first,right)内vector容器中的所有元素。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; ve.erase(ve.begin()+1,ve.begin()+4); //删去下标为[1,4)的元素 for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } 所以清空vector容器除了上面提到的clear()函数外，现在也可以使用第二种方法：ve.erase（ve.begin（）,ve.end（））。这样只是加深对“左闭右开”的理解，因为ve.end（）指向的是末尾元素的下一个位置。当然clear（）函数明显更加方便、简洁。 string在C语言中，通常使用字符数组char s[] 来对字符串进行存储，在此基础上为了对字符串的操作更加的快捷、方便，C++在STL中加入了string类型，对字符串的常用功能进行了封装。如果要使用string，需要添加头文件\\（注意string.h和string是完全不一样的头文件）。下面来看看string容器的常用使用方法吧。 string的定义定义 string 的方式和其他的基本数据类型一致，只需要在 string 后面加上变量的名称即可。如果要进行初始化，定义时直接进行赋值即可。 string str; //定义 string str=\"abcd\"; //赋值 访问string容器中的元素（1）通过下标访问： 一般而言，可以像访问字符数组那样通过下标对string容器进行访问。 （2）通过迭代器访问： 定义迭代器： string::iterator it; //string类型无其他参数 关于使用迭代器对string容器中的元素进行访问的方法，类似于上文中的vector容器，在这里就不做过多阐述，可以参照上文。 如果要读入和输出整个字符串，则只能使用cin和cout。 最后需要注意的一点，string和vector一样，支持直接对迭代器进行加减某个数字，比如说str.begin（）+2 的写法是合法的。而对于STL的其他容器，则不支持这种写法。 string容器的常用函数（1）比较与拼接 因为 string 在C++中是一种数据类型，则可以像其他的变量一样进行加法运算及比较运算（比较的是字典序）。比如说： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abc\",str2=\"123\"; string str; str=str1+str2; cout&lt;&lt;str&lt;&lt;endl; //输出abc123 string str3=\"aaabc\",str4=\"aabc\"; cout&lt;&lt;(str3&gt;str4)&lt;&lt;endl; //返回0，str3字典序大于str4 return 0; } （2）length（）和 size（）函数 这两个函数都是返回 string 的长度，作用和运行效率基本相同。 （3）insert（）函数 string的insert（）函数，常见的写法有两种。 ①insert（pos，string），pos为string容器中的位置，string为待插入的字符串。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abcde\",str2=\"123\"; str1.insert(3,str2); //在str[3]处插入了“123” cout&lt;&lt;str1&lt;&lt;endl; //输出abc123de } ②insert（it，it2，it3）使用三个迭代器的写法，it 指向原字符串待插入的位置，it1、it2指向待插字符串的首尾元素，来表示串 [ it1,it2 )插入到 it 位置。（左闭右开原则） #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abcde\",str2=\"123\"; str1.insert(str1.begin()+3,str2.begin(),str2.end()); cout&lt;&lt;str1&lt;&lt;endl; //abc123de } （4）erase（）函数 （5）clear（）函数 这两个函数用法和vector容器的用法一致，可以参照上文。 （6）substr（）函数 substr（pos，len）返回从pos号位置开始，长度为len的子串。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a nice day\"; cout&lt;&lt;str.substr(0,5)&lt;&lt;endl; //输出Today cout&lt;&lt;str.substr(11,4)&lt;&lt;endl; //输出nice } （7）find（）函数 str.find（str1)，即在str中找是否存在子串str1，若存在则返回子串首次出现的位置，否则返回string::npos常数（最大的unsigned_int，也相当于-1。） str.find（str1，pos)即将开始查找的位置定为pos，返回值和上面相同。 时间复杂度为 O（mn） 故使用需谨慎考虑时间复杂度。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a nice day\"; cout&lt;&lt;str.find(\"nice day\")&lt;&lt;endl; //返回11 cout&lt;&lt;str.find(\"bad day\")&lt;&lt;endl; if(str.find(\"bad day\")==-1)cout&lt;&lt;\"-1\"&lt;&lt;endl; } （10）replace（）函数 str.replace（pos，len，str1）把str的pos号位置开始，长度为len的子串替换为str1。 str.replace（it1，it2，str1）把str [ it1，it2 ) 替换为str1。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a bad day\"; cout&lt;&lt;str&lt;&lt;endl; string str1=\"nice\",str2=\"Tomorrow\"; str.replace(11,3,str1); cout&lt;&lt;str&lt;&lt;endl; //输出 Today is a nice day str.replace(str.begin(),str.begin()+5,str2); cout&lt;&lt;str&lt;&lt;endl; //输出 Tomorrow is a nice day } （11）字符串和数字的相互转换 数字-&gt;字符串（to_string函数） to_string（val）val的值能够自动判别类型，返回值是string； #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main (){ string s1,s2; int x=4595; s1=to_string(x); cout&lt;&lt;s1&lt;&lt;endl; long long y=123456789101112; s2=to_string(y); cout&lt;&lt;s2&lt;&lt;endl; return 0; } 字符串-&gt;数字 常用的有stoi（）、stoll（）、stof（）、stod（），分别将字符串转化为int、long long、float、double类型的数字。依葫芦画瓢，其他类型同样是这样的形式。 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main (){ string s1,s2; s1=\"3.14159\"; double pi=stod(s1); cout&lt;&lt;pi&lt;&lt;endl; s2=\"1234567891011121314\"; long long x=stoll(s2); cout&lt;&lt;x&lt;&lt;endl; return 0; } setset在英文中翻译为集合，是一个内部自动有序且不含重复元素的容器。如果要使用set容器，则需要在头文件中添加&lt; set &gt;。 set的定义set的定义的写法其实和vector基本上是一样的，或者说大部分STL容器都是这样定义的。 #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;typename&gt; name; //一维 set&lt;typename&gt; arrayname[arraysize]; //二维 } set容器内元素的访问set 容器内的元素只能通过迭代器进行访问。且 set 容器不支持*（it+i）的访问方式，因此常用的枚举方式如下： #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; //定义set容器 st.insert(2); //用insert插入元素 st.insert(1); st.insert(3); st.insert(2); set&lt;int&gt;::iterator it; //定义迭代器 for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 cout&lt;&lt;endl; } 从输出结果可以发现，set容器内部自动实现了递增排序且删除了重复的元素。 set容器常用函数 insert（） insert（x）可将x插入容器中，且实现自动升序和去重，时间复杂度是O（logN）其中 N 是当前容器中的元素个数。 find（） find（x）返回set容器中对应值为x的迭代器（而不是下标 string返回的是对应下标），时间复杂度是O（logN）其中 N 是当前容器中的元素个数。 earse（） 同样，erase函数有两种用法：单个元素和区间元素删除。 （1）删除单个元素： erase（it）即删去迭代器 it 处的元素。可结合find（）函数进行使用。 示例如下： #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; for(int i=1;i&lt;5;i++) st.insert(i); set&lt;int&gt;::iterator it; it=st.find(3); st.erase(it); for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 cout&lt;&lt;endl; } erase（value），value为待删除元素的值。时间复杂度为O（N) #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; for(int i=1;i&lt;5;i++) st.insert(i); set&lt;int&gt;::iterator it; st.erase(3); for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 cout&lt;&lt;endl; } （2）删除一个区间内的所有元素 用法和上文提到的vector容器的用法一致，可以参照上文。 size（） clear（） 用法同样是类似的，在这里就不做过多的阐述了。 mapmap在英文中翻译为映射，也是常用的STL容器。 一个简单的引入：在定义数组时（比如说int array[ 100 ]),其实就可以理解为一个int -&gt; int 的映射。而map容器则可以将任何数据类型映射到任何数据类型（当然也包括STL容器）。 map容器的定义单独定义一个map： map&lt;typename1,typename2&gt; mp; 我们把映射前类型称为键（key），映射后类型称为值（value）。 特别说明：当字符串作为键值时，不能使用char[ ]型的数组，而应该是使用string容器。并且，map中的键是唯一的，和数学中的映射概念是一致的。 map容器内元素的访问map容器一般有两种访问方式：通过下标访问或通过迭代器访问。下面来讨论这两种访问方式。 （1）通过下标访问 和引入部分提到的，就和访问普通的数组是一样的，可以通过下标进行赋值和访问。 #include&lt;iostream&gt; #include&lt;map&gt; //记得添加头文件 using namespace std; int main () { map&lt;char,int&gt;mp; char ch='a'; for(int i=1;i&lt;=26;i++) { mp[ch]=i; //赋值 ch++; } cout&lt;&lt;mp['h']&lt;&lt;\" \"&lt;&lt;mp['k']&lt;&lt;endl; //输出8 11 return 0; } （2）通过迭代器访问 map容器的迭代器定义方式和其他STL容器迭代器定义方式相同。 但是因为在定义时有两个数据类型，所以在使用map容器的迭代器时，可以使用 it -&gt; first 来访问键，使用 it -&gt; second 来访问值。 例如： #include&lt;iostream&gt; #include&lt;map&gt; using namespace std; int main () { map&lt;char,int&gt;mp; char ch='a'; for(int i=1;i&lt;=5;i++) { mp[ch]=i; ch++; } map&lt;char,int&gt;::iterator it; for(it=mp.begin();it!=mp.end();it++) { cout&lt;&lt;it -&gt; first&lt;&lt;\" \"&lt;&lt;it -&gt; second&lt;&lt;endl;//输出a-e 1-5 } return 0; } 虽然上面代码赋值是从小到大，但是实际上map容器的键值会以从小到大的顺序自动排序（类似于 set容器内部使用红黑树来实现）。 map容器常用函数 find（）函数 find（key）返回键值为key的映射的迭代器，时间复杂度为O（logN） erase（）函数 mp.erase（x）其中x可以为键值或者迭代器 区间删除类似于set容器，可以参照上文的set容器。 size（）函数 得到的是映射的对数 clear（）函数 用法同样类似，在此不做赘述。 stack stack的英文翻译是栈，是STL中实现后进先出的容器。 stack定义stack定义方法和上面提到的容器类似，typename可以是任意的数据类型。使用stack容器时，头文件一定不要忘记添加#include&lt; stack &gt; stack容器内元素的访问由于stack容器后进先出的特性，故只能通过top（）来访问栈顶元素 简单例子： #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main () { stack&lt;int&gt; st; for(int i=0;i&lt;5;i++) st.push(i); cout&lt;&lt;st.top()&lt;&lt;endl; //输出 4 } 从上面这个例子不难看出stack容器后进先出的特性以及top（）函数的用法。 stack容器常用函数的使用 push（） push（x）将元素x入栈，时间复杂度为 O（1） top（） 获取栈顶元素 pop（） 弹出栈顶元素 empty（） 用以检查栈内元素是否为空，若为空即返回true，否则返回false。 size（） 返回容器内的元素个数 queue queue的英文翻译是队列，是STL中实现先进先出功能的容器。 queue容器的定义首先还是要提醒使用时记得添加头文件#includ&lt; queue &gt;，其余写法和其他的STL容器类似。 queue容器内的元素访问参照栈，由于队列具有先进先出的特性，所以queue容器只允许通过front（）和back（）来访问队列中对首元素和队尾元素。 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { queue&lt;int&gt;q; for(int i=0;i&lt;5;i++) q.push(i); cout&lt;&lt;q.front()&lt;&lt;\" \"&lt;&lt;q.back(); //输出： 1 5 return 0; } queue常用函数 push（） front（）、back（） 以上函数在上面示例可以看到简单用法 pop（） pop（）函数令队首元素出队，时间复杂度是O（1） empty（） 检查queue容器内是否为空，若为空返回true，否则返回false size（） 返回queue容器内的元素个数。 priority_queuepriority_queue又称为优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是优先级别最高的元素。当然这里的优先级则是规定出来的。 priority_queue容器的定义定义方式和queue容器的定义方式相同 priority_queue容器内元素的访问和queue容器不同的是，priority_queue容器并没有front（）函数和back（）函数，只能通过top（）函数来访问其堆顶元素（即优先级别最高的元素） 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { priority_queue&lt;int&gt;pq; for(int i=0;i&lt;5;i++) pq.push(i*2); for(;;) { if(pq.empty())break; cout&lt;&lt;pq.top()&lt;&lt;\" \"; pq.pop(); } cout&lt;&lt;endl; //输出： 8 6 4 2 0 return 0; } 可以发现，在未涉及优先级时，用法是和queue容器大同小异的。 priority_queue容器的常用函数 push（） top（） pop（） empty（） size（） 以上函数都可以在上面的示例当中看到简单应用。 priority_queue内元素的优先级的设置如何定义优先队列中的元素优先级是运用好优先队列的关键，下面来介绍设计首先队列元素的优先级别的方法。 基本数据类型的优先级设置这里提及的基本数据类型包括：int、char、double，优先队列对其默认是数字越大的优先级别越高（char型则比较的是字典序），则默认写法的详细写法为： priority_queue&lt;int&gt; name; priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; name; //以上两种写法是完全等价的 若使用char或double则将int全部改为char或double即可。 若想设置数字越小优先级别越高，将less&lt; int &gt;替换为greater&lt; int &gt;即可 #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;pq; for(int i=0;i&lt;5;i++) pq.push(i*2); for(;;) { if(pq.empty())break; cout&lt;&lt;pq.top()&lt;&lt;\" \"; pq.pop(); } cout&lt;&lt;endl; //输出0 2 4 6 8 return 0; } 结构体的优先级的设置引入一个小小的例子，对商品的名称及价格建立一个结构体，并且规定价格高的商品优先级别更高。 struct goods{ string name; int price; }; //定义结构体 为实现优先级的规定，必须在结构体中添加比较功能。 struct goods{ string name; int price; friend bool operator &lt; (goods g1, goods g2){ return g1.price &lt; g2.price } //重载小于号“&lt;” }; 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;string&gt; using namespace std; struct goods { int price; string name; friend bool operator &lt; (goods g1, goods g2) { return g1.price&lt;g2.price; } }; int main () { goods g1,g2,g3; priority_queue&lt;goods&gt; q; g1.name=\"milk\";g1.price=10; g2.name=\"apple\";g2.price=8; g3.name=\"meet\";g3.price=12; q.push(g1); q.push(g2); q.push(g3); for(;;) { if(q.empty())break; cout&lt;&lt;q.top().name&lt;&lt;\" \"&lt;&lt;q.top().price&lt;&lt;endl; q.pop(); } return 0; } //输出： meet 12 milk 10 apple 8 这里的重载符号的作用其实和sort函数中的cmp函数相似，但是实现的效果两者是相反的（在排序中return的是“&gt;”那么就是从大到小排序），这一点需要特别注意。 pair同样顾名思义，pair的英文翻译是：一对、一双，也即把两个元素绑在一起当作一个合成元素。可以理解为一个内部有两个元素的结构体。 pair的定义要使用pair容器首先必须添加头文件#include&lt; utility &gt;，需要注意的是，由于map容器的内部涉及到了pair，所以如果头文件中添加了#include&lt; map &gt;就可以直接使用pair容器。 对比结构体和pair： struct pair{ typename1 first; typename2 second; } pair&lt;typename1,typename2&gt; name; pair容器内元素的访问pair容器内只存在两个元素，访问方式和结构体访问方式类似。 示例如下： #include&lt;utility&gt; #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; int main () { pair&lt;string,int&gt;p(\"abc\",123); cout&lt;&lt;p.first&lt;&lt;\" \"&lt;&lt;p.second&lt;&lt;endl; return 0; } 常见用法有： 比较操作数 两个pair类型数据可以直接使用==、！=、&lt;等比较大小，比较规则是先比较first，在first相同的情况下才去比较second的大小。 作为map的键值进行插入 listlist容器的定义list是双向循环列表，每一个元素都知道前一个元素和后一个元素，所以和vector相比，list能够更快的插入和删除，但是随机访问却比较慢。 定义与初始化： list&lt;typename&gt; lis1;//创建空的list list&lt;typename&gt; lis1(n);//创建含有n个元素的list list&lt;typename&gt; lis1(n,val);//创建n含有n各元素且值为val的list list&lt;typename&gt; lis1(lis2);//用lis2初始化lis1 list的访问与常用函数 assign（）函数用于赋值 begin（），end（）返回首尾元素的迭代器 front（），back（）返回首尾元素 size（）返回容器的元素个数 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis1; list&lt;int&gt;lis2(4, 10); int num[6] = {2, 17, 4, 55, 78, 16}; lis1.assign(lis2.begin(), lis2.end()); list&lt;int&gt;::iterator it; for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; //输出：10 10 10 10 cout &lt;&lt; endl; lis1.assign(num, num + 6); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \";//输出：2,17,4,55,78,16 cout &lt;&lt; endl; return 0; } 5.erase（）动态删除，返回当前迭代器的下一个节点（返回迭代器）。区间删除，单个删除均可以实现。 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis; for (int i = 1; i &lt;= 8; i++) lis.push_back(i); list&lt;int&gt;::iterator it, it1, it2; for (it = lis.begin(); it != lis.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \" ;//输出： 1 2 3 4 5 6 7 8 cout &lt;&lt; endl; it1 = it2 = lis.begin(); advance(it2, 6); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl; //输出 1 7 it1 = lis.erase(it1); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl; //输出 2 7 it2 = lis.erase(it2); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl;// 输出 2 8 it1++; it2--; lis.erase(it1, it2);//输出2 6 8 for (it = lis.begin(); it != lis.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \" ; cout &lt;&lt; endl; return 0; } 6.insert（）插入元素 单个元素以及区间插入均可实现 特别注意：返回的迭代器是原来的位置，插入的坐标迭代器指向的元素不变。 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis; for (int i = 1; i &lt;= 6; i++) lis.push_back(i); list&lt;int&gt;::iterator it = lis.begin(), it1; it1 = lis.insert(it, 10); cout &lt;&lt; *it &lt;&lt; endl &lt;&lt; *it1 &lt;&lt; endl;//it指向1 it1指向10 return 0; } 7.splice（）把链表中的元素从一个移到另一个链表中（可以理解为剪切函数）函数无返回值 常见有三种用法，代码如下： #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis1{1, 2, 3, 4, 5}; list&lt;int&gt;lis2{11, 22, 33, 44, 55}; //用法一 auto it = lis1.begin(); advance(it, 3); lis1.splice(it, lis2); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; if (lis2.empty()) cout &lt;&lt; \"lis2 is empty\" &lt;&lt; endl; /* 注意两点： 1.插入的位置（在迭代器指向的位置之前插入lis2） 2.lis中的元素被转移后容器清空了 时间复杂度常数级别 */ //用法二 cout &lt;&lt; endl &lt;&lt; endl; it = lis1.begin(); lis2.splice(lis2.begin(), lis1, it); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; for (it = lis2.begin(); it != lis2.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; /* 同样注意用法一的那两点 时间复杂度常数级别 */ //用法三 cout &lt;&lt; endl &lt;&lt; endl; it = lis1.begin(); advance(it, 3); // it-&gt;22 lis2.splice(lis2.end(), lis1, it, lis1.end()); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; for (it = lis2.begin(); it != lis2.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; /* 注意： 1.区间插入 左闭右开 2.删除原有元素 3.插入的位置 时间复杂度线性级别 */ return 0; } 8.merge（）合并两个有序的list，合并后仍然有序。（默认是递增的） 9.reverse（)倒转list END","categories":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"}],"author":"HeeKaai"},{"title":"C语言期末复习笔记","slug":"C语言期末复习笔记","date":"2022-01-06T15:24:12.000Z","updated":"2022-01-10T06:24:58.032Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://heekaai.github.io/posts/1.html","excerpt":"","text":"[TOC] 前言​ 临近期末考试（C语言程序设计），本人也是从暑假（7月份）开始接触的C语言，可以说是一只纯正的小白，为了更好、更有效率的备考，这篇博客也就由此诞生了。 ​ 顺序没啥讲究，完全是想到了什么就写出来了。很多算法优化空间还有很大。 动态规划初步​ 动态规划其实我感觉也可以叫作记忆化的递归优化，顾名思义，就是一种把递归可能会产生的重复运算记录下来，以空间换时间（当然空间复杂度的代价也是可以降到最小的，比如说滚动数组来实现）。 DP的组成部分​ 几乎每一道可以用动态规划来解决的题目，设计算法的时候都可以被拆解为以下的几步： 确定状态（定海神针的作用） 最后一步 子问题 （由最后一步将问题分解，即解决子问题+最后一步） 确定状态转移方程 子问题定下来，状态转移就是子问题的一般化过程 初始化与边界 计算顺序 这四步听起来好像不太好理解，但是动态规划的核心就在这。通过题目应该可以更好的思考和理解动态规划的组成部分。 例题坐标型DP题目描述： &gt;&gt; 如图，A 点有一个过河卒，需要走到目标 B 点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如上图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图 C 点上的马可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。 棋盘用坐标表示，A 点（0,0）、B 点（n,m）(n,m 为不超过 20 的整数，并由键盘输入)，同样马的位置坐标是需要给出的（约定: C&lt;&gt;A，同时C&lt;&gt;B）。现在要求你计算出卒从 A 点能够到达 B 点的路径的条数。 输入描述： 输入B点的坐标（n,m）以及对方马的坐标（X,Y） (不用判错) 输出描述： 输出一个整数表示路径的条数。 样例输入： 6 6 3 2 样例输出： 17 原题链接：Nowcoder-过河卒 题目分析： 参照上面的DP组成部分，一步一步来： 最后一步：最后一定会到达（n，m）的位置 子问题：在没有马控制的前提下，一定是由（n-1，m）或者（n，m-1）过来 状态转移方程：dp[i] [j]=dp[i-1] [j]+dp[i] [j-1] 初始化与边界：首先马的领地是不能到的，直接记为0；然后就是第一行和第一列都是1；在初始化第一行第一列的时候，遇到马就直接break，因为后面的都到不了了； AC代码： #include&lt;stdio.h&gt; #include&lt;stdbool.h&gt; #include&lt;string.h&gt; long long dp[25][25]; bool judge[25][25];//判断是否为马的领地，布尔数组合适 int main () { memset(judge,true,sizeof(judge)); int n,m,x,y; scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;x,&amp;y); judge[x][y]=0; judge[x-2][y-1]=judge[x-2][y+1]=judge[x-1][y-2]=judge[x-1][y+2]=0; judge[x+2][y-1]=judge[x+2][y+1]=judge[x+1][y-2]=judge[x+1][y+2]=0; for(int i=0;i&lt;=m;i++) { if(judge[0][i])dp[0][i]=1; else break; } for(int j=0;j&lt;=n;j++) { if(judge[j][0])dp[j][0]=1; else break; } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(judge[i][j])dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } printf(\"%lld\\n\",dp[n][m]); } 序列DP原题链接：XTUOJBlocks 题目描述： 给你一个n块积木，每个积木块都是立方体，现在把它们排列一排，成m列，要求每列上至少有1个积木，且从左到右，每列的积木数量呈严格单调下降。 ​ 题意即求n等于m个不同的数相加的方案数 最后一步：m个数不同，则一定有最大的数，记为k。 子问题：则求解n-k等于m-1个不同的数相加的方案数。 状态转移方程： dp(i,j,k)=\\sum_{t","categories":[{"name":"C语言","slug":"C语言","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"算法笔记","slug":"C语言/算法笔记","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"C语言/算法笔记/基础","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"C","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"学习","slug":"学习","permalink":"https://heekaai.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"基础算法","slug":"基础算法","permalink":"https://heekaai.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"author":"HeeKaai"},{"title":"博客的诞生","slug":"博客的诞生","date":"2022-01-03T14:35:02.000Z","updated":"2022-01-19T02:20:57.023Z","comments":true,"path":"posts/3c47c717.html","link":"","permalink":"https://heekaai.github.io/posts/3c47c717.html","excerpt":"","text":"相遇就是缘！ 为什么要搭建博客？纯属自己的个人兴趣吧！记录自己最近都干了什么，学到了什么，或许会有一些成就感吧！拥有一个自己的博客写一写自己感兴趣或者正在研究的事或物，不是一件很有意义的事情嘛！ 展望博客我会整理一些自己目前在学的东西，一方面能够让自己复习，一方面也能记录一下学习的过程，也希望能够让有兴趣的小伙伴能够看到，也是一个共同进步的过程。 关于博主我真的是一个很懒很懒的人，平时最喜欢干的事情就是睡觉。希望通过写博客来提高提高自己的学习积极性。 “人间失格”听上去真的很非主流，我自己也这么觉得。但是取名字我觉得更加麻烦，《人间失格》是太宰治的一本书，索性就直接引用过来了。 最后拿《人间失格》里的一句话作结吧 如今的我，谈不上幸福，也谈不上不幸。 一切都会过去的。 在所谓的“人世间”摸爬滚打至今， 我唯一愿意视为真理的，就只有这一句话， 一切都会过去的！ ​ ————太宰治《人间失格》 感谢你看到了最后！","categories":[{"name":"简介","slug":"简介","permalink":"https://heekaai.github.io/categories/%E7%AE%80%E4%BB%8B/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://heekaai.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"HeeKaai"},{"title":"Hello World","slug":"hello-world","date":"2022-01-02T12:28:30.418Z","updated":"2022-01-02T15:36:49.102Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://heekaai.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"快速幂","slug":"快速幂","permalink":"https://heekaai.github.io/categories/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"矩阵的计算","slug":"快速幂/矩阵的计算","permalink":"https://heekaai.github.io/categories/%E5%BF%AB%E9%80%9F%E5%B9%82/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%AE%A1%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"最小生成树","slug":"算法/最小生成树","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"最短路径","slug":"算法/最短路径","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"动态连通性问题","slug":"算法/数据结构/动态连通性问题","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"},{"name":"基础","slug":"算法/基础","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/"},{"name":"CRT模板","slug":"算法/基础/CRT模板","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/"},{"name":"扩展欧几里得","slug":"算法/基础/CRT模板/扩展欧几里得","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"},{"name":"C语言","slug":"C语言","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"算法笔记","slug":"C语言/算法笔记","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"C语言/算法笔记/基础","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80/"},{"name":"简介","slug":"简介","permalink":"https://heekaai.github.io/categories/%E7%AE%80%E4%BB%8B/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"模板","slug":"模板","permalink":"https://heekaai.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"https://heekaai.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"https://heekaai.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"},{"name":"C","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"学习","slug":"学习","permalink":"https://heekaai.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"基础算法","slug":"基础算法","permalink":"https://heekaai.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"生活","slug":"生活","permalink":"https://heekaai.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}