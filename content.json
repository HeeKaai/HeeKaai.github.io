{"meta":{"title":"人间失格","subtitle":"人间失格の博客","description":"本科 | 计算机科学与技术 | 算法笔记","author":"HeeKaai","url":"https://heekaai.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.398Z","comments":true,"path":"404.html","permalink":"https://heekaai.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-01-02T12:43:43.492Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://heekaai.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/index.html","permalink":"https://heekaai.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"archives/index.html","permalink":"https://heekaai.github.io/archives/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-02T12:43:43.492Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://heekaai.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"friends/index.html","permalink":"https://heekaai.github.io/friends/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"census/index.html","permalink":"https://heekaai.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T14:48:55.758Z","comments":true,"path":"contact/index.html","permalink":"https://heekaai.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 人间失格の友链信息 博客名称: 人间失格の博客 博客网址: https://heekaai.github.io 博客头像: https://s4.ax1x.com/2022/01/02/TTxWtK.jpg 博客介绍: 接受平凡，努力出众"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"about/index.html","permalink":"https://heekaai.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"categories/index.html","permalink":"https://heekaai.github.io/categories/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"resource/index.html","permalink":"https://heekaai.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.492Z","comments":true,"path":"tags/index.html","permalink":"https://heekaai.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/index.html","permalink":"https://heekaai.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/movies/index.html","permalink":"https://heekaai.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/music/index.html","permalink":"https://heekaai.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/tools/index.html","permalink":"https://heekaai.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://heekaai.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://heekaai.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://heekaai.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://heekaai.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://heekaai.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-02T12:43:43.414Z","updated":"2022-01-02T12:43:43.414Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://heekaai.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"并查集","slug":"并查集","date":"2022-03-12T07:12:31.911Z","updated":"2022-03-12T09:25:23.687Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://heekaai.github.io/posts/5.html","excerpt":"","text":"定义并查集是一种维护集合的数据结构，用以解决动态连通性问题。顾名思义，“并”—“合并”—“Union”；“查”—“查找”—“Find”；“集”—“集合”—“Set”。主要需要支持查找和合并两个操作。 通常而言，并查集使用一个数组来实现： int father[N]; 数组含义如下： $father[i]$表示元素 i 的父亲结点，其父亲结点也一定是这个集合里的元素。特别的，如果$father[i]=i$,则说明元素i是该集合的根节点，且对同一个集合只存在一个根节点，所以根节点也是这个集合的一个重要标识。 基本操作的实现初始化int father[N]{}; void init() { for(int i=1;i&lt;N;i++) father[i]=i; } 初始化每一个元素都是根节点，独立成一个元素。 查找通过递归实现 int find_root(int x){ if(x==father[x])return x; else return find_root((father[x])); } 合并合并是指把两个集合合并成一个集合，只有两个集合是不同集合时，才能够合并。合并的过程是把一个集合的根节点的父亲指向另一个集合的根节点。 void Union(int a,int b){ int faA=find_root(a); int faB=find_root(b); if(faA==faB)return; father[faB]=faA; //father[faA]=faB也是可以的 } 特别注意： 一定是根节点和根节点的互相指向关系。 不能对同一个集合的元素进行合并操作，否则将会产生一个闭环，从而破坏了其本身作为“树”的结构。 路径压缩上面并合集的基本操作都非常简单，所以不做过多解释。现在考虑一个问题：对于一个链型的数据集合，要查找链条中的最后一个元素的父亲根结点，时间复杂度达到了O（N），这显然是无法接受的。所以我们应该想办法将其优化。 这样处理之后，每一个子元素的查询时间复杂度是不是就可以降至O（1）。 现在，只需要把这样的处理改写成代码即可。 还是递归的写法： int find_root(int x){ if(x==father[x])return x; else{ int F=find_root(father[x]); //寻找到根结点 father[x]=F; return F; } } 在寻找的时候，实现了路径上的元素的路径压缩。 例题放上一道例题（考查并集的裸题）： Learning Languages 题目描述： 一个公司有n个员工，会使用m种语言，给出每个人会使用的语言（可以一种都不会），每个人学习不会的语言会花费1个单位的钱，为了让任意两个员工都能够交流（其他员工可以当他们的翻译），现在要求求出最小花费。 思路： 并查集的思路，最后数出有多少根节点即可。（详细的结合代码理解） AC代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 107; int t, n, m; int num[maxn]{}; /*num[i]的含义：第i种语言，员工num[i]第一个掌握（输入顺序的第一），后面出现 会这种语言的自然是他的子节点*/ int father[maxn]{}; void init() { for (int i = 0; i &lt; maxn; i++) father[i] = i; } int find_root(int x) { if (x == father[x])return x; else return find_root((father[x])); } void _union(int a, int b) { int faA = find_root(a); int faB = find_root(b); if (faA == faB)return; father[faB] = faA; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(0); cin &gt;&gt; n &gt;&gt; m; int ans = 0; memset(num, 0, sizeof(num)); init(); for (int i = 1; i &lt;= n; i++) { int t; cin &gt;&gt; t; while (t--) { int x; cin &gt;&gt; x; if (num[x] == 0)num[x] = i; else { if (i == father[i]) { father[i] = num[x]; }else{ int F1 = find_root(i); int F2 = num[x]; _union(F1, F2); //该员工当翻译，合并两个集合 } } } } bool all0 = 1; for (int i = 1; i &lt;= m; i++) { if (num[i] != 0) { all0 = 0; break; } } if (all0) { cout &lt;&lt; n &lt;&lt; endl; return 0; } for (int i = 1; i &lt;= n; i++) { if (i == father[i])ans++; } ans--; cout &lt;&lt; ans &lt;&lt; endl; return 0; } 运用的函数都是上文提到过的，此题查找部分不需要压缩路径（数据范围很小），特别注意最后的all0的特判（没有人会公司的官方语言）。 END","categories":[{"name":"算法","slug":"算法","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"动态连通性问题","slug":"算法/数据结构/动态连通性问题","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://heekaai.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"HeeKaai"},{"title":"扩展欧几里得算法和中国剩余定理","slug":"扩展欧几里得算法和中国剩余定理","date":"2022-03-08T11:44:14.111Z","updated":"2022-03-12T09:26:28.326Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://heekaai.github.io/posts/4.html","excerpt":"","text":"[TOC] 扩展欧几里得算法扩展欧几里得算法就是对ax+by=gcd（a，b）的求解 问题引入：给定两个整数a和b，求一组解（x，y）使得等式ax+by=gcd（a，b）成立。（解一定存在的，有定理证明过） 回顾一下欧几里得算法（辗转相除法） int gcd(int a,int b){ if(b==0)return a; else return gcd(b,a%b); } （为了不弄混淆，记g=gcd（a，b），这里的a和b是最初的值） 观察跳出函数时的情况，a=g，b=0；此时x=1，y=0则是方程的解。按照这样的思路，是不是只要反推就可以得到最初的x，y的值。 下面是得到递推式的推导过程 现在有了递推边界和递推式，就可以得到求解的代码： int ex_gcd(int a, int b, int&amp; x, int&amp; y) //利用引用，直接修改x、y的值 { if (b == 0) //递归边界 { x = 1; y = 0; return a; //a=g } int g = ex_gcd(b, a % b, x, y); int temp = x; x = y; y = temp - a / b * y; return g; } 纯净版： int ex_gcd(int a, int b, int&amp; x, int&amp; y) { if (b == 0) { x = 1; y = 0; return a; } int g = ex_gcd(b, a % b, x, y); int temp = x; x = y; y = temp - a / b * y; return g; } 符号和上述推导一致，应该很容易看明白。由于x，y是引用，故函数结束时x，y的值就是一组解；得到一组解就很容易将其推广到无数组解： 扩展欧几里得算法的应用： ax+by=c的求解 同余式的求解 逆元的求解 中国剩余定理（CRT）问题引入：已知一个数除以3余2，除以5余3，除以7余2，求解这个数。（孙子问题的白话版） \\begin{cases} n1=k1*3+2\\\\ n2=k2*5+3\\\\ n3=k3*7+2\\\\ x=n1+n2+n3 \\end{cases} n1除以3余2，且是5,7的公倍数 ==》n1=35 n1除以5余3，且是3,7的公倍数 ==》n1=63 n1除以7余2，且是3,5的公倍数 ==》n1=30 则x=（35+63+30）= 128 x_{min}=x_{now}\\%gcd(3,5,7)=128\\%105=23这就是著名的的孙子问题。我们再来看中国剩余定理的定义： 设正整数$m1,m2,······,mk$ 两两互素，则同余方程组： \\begin{cases} x\\equiv a_{1}(mod\\ m_{1})\\\\ x\\equiv a_{2}(mod\\ m_{2})\\\\ ······\\\\ x\\equiv a_{k}(mod\\ m_{k})\\\\ \\end{cases}一定会有整数解，并且在模M（$M=\\prod_{i=1}^{m}m_i$）下的解是惟一的，x的值为： x\\equiv (a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+···+a_kM_kM_k^{-1})\\ mod\\ M其中$M_i={M\\over m_i}$ ,而$M_i^{-1}为M_i模m_i的逆元$ 上面就是中国剩余定理的完整描述，也就可以得到下面的代码模板了： //情况一：n个数互质 const int maxn = 2007 ; int a[maxn], m[maxn], n; int CRT() { int M = 1; for (int i = 0; i &lt; n; i++) M *= m[i]; int ret = 0; for (int i = 0; i &lt; n; i++) { int x, y; int tm = M / m[i]; ex_gcd(tm, m[i], x, y); ret = (ret + tm * x * a[i]) % M; } return (ret + M) % M; } 现在把情况更加一般化，如果n个数不互质呢，其实也是可以转化的，（证明省略），直接上代码： //情况二：n个数不互质 int a[maxn], m[maxn], n; int CRT() { if (n == 1) { if (m[0] &gt; a[0])return a[0]; else return -1; } int x, y, d; for (int i = 1; i &lt; n; i++) { if (m[i] &lt;= a[i])return -1; d = ex_gcd(m[0], m[i], x, y); if ((a[i] - a[0]) % d != 0)return -1; int t = m[i] / d; x = ((a[i] - a[0]) / d * x % t + t) % t; a[0] = x * m[0] + a[0]; m[0] = m[0] * m[i] / d; a[0] = (a[0] % m[0] + m[0]) % m[0]; } return a[0]; } END","categories":[{"name":"算法","slug":"算法","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"基础","slug":"算法/基础","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/"},{"name":"CRT模板","slug":"算法/基础/CRT模板","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/"},{"name":"扩展欧几里得","slug":"算法/基础/CRT模板/扩展欧几里得","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"模板","slug":"模板","permalink":"https://heekaai.github.io/tags/%E6%A8%A1%E6%9D%BF/"}],"author":"HeeKaai"},{"title":"STL入门--algorithm头文件","slug":"STL入门-algorithm头文件","date":"2022-02-18T02:51:59.312Z","updated":"2022-03-02T08:36:37.022Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://heekaai.github.io/posts/3.html","excerpt":"","text":"[TOC] algorithm头文件下的常用函数前提：添加algorithm头文件 max（）、min（）和abs（）max（x，y）和min（x，y）分别返回x和y中的最大值和最小值，且参数必须是两个（可以是浮点数）。如果想要返回三个数x、y、z的最大值，可以通过max（x，max（y，z））的写法。 abs（x）返回x的绝对值。注意：x必须是整数，浮点型的绝对值请用math头文件下的fabs。 swap（）swap（x，y）用以交换x和y的值 reverse（）reverse（it1，it2）可以将数组指针在[ it1, it2 ）之间的元素或迭代器在[ it1, it2 ）范围内的元素进行反转。（左闭右开的特点）示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt;ve; int num[9]; for (int i = 0; i &lt; 6; i++) { num[i] = i; ve.push_back(i); } vector&lt;int&gt;::iterator it=ve.begin(); reverse(it + 1, it + 4); reverse(num + 1, num + 4); for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; ve[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; num[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; //输出：0 3 2 1 4 5 return 0; } next_permutation（）next_permutation（）给出一个序列在全排列中的下一个序列。 全排列是按照字典序由小至大的顺序进行排序。 并且值得注意的是其返回值，若存在下一个排序，返回值是true；若不存在最后一个排序（即当前为最后一个全排列），返回值则为false。根据这一特性，通常会使用do···while···循环来实现全排列。 下面是1-9全排列的代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main () { int num[9]; for(int i=0;i&lt;9;i++) num[i]=i+1; do{ for(int i=0;i&lt;9;i++) cout&lt;&lt;num[i]&lt;&lt;\" \"; cout&lt;&lt;endl; }while(next_permutation(num,num+9)); return 0; } fill（）fill（）函数可以将数组或容器某区间内所有元素全部赋值为同一值，用法和memset类似，但是fill（）函数的赋值可以是数据范围内的一值。 具体用法： fill(it1,it2,num)； //it可以是指针或者是迭代器 sort（）顾翻译思义，sort就是用来排序的函数，效率较高。相比于C语言中的qsort函数，sort函数用起来更加便捷，并且规避某些效率特别低的情况。 sort函数的三个参数 第一个是要排序的数组的起始地址。 第二个是结束的地址（最后一位要排序的地址）的下一个地址 比较函数 其中第三点非必填内容，若不填，则默认递增的顺序 一定特别需要注意的是：“左闭右开”第二个参数是末尾元素的下一个地址 比较函数cmp的书写cmp函数的书写就好比人为给sort（）函数制定比较规则一样，让sort（）函数按照自己的想法进行排序。 基本数据类型 基本数据类型本身就具有可比性，则默认即为增序。只需记忆递减的情形下的cmp函数。 示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; bool cmp(int a, int b) { return a &gt; b; } int main() { int num[5]{3,8,1,2,4}; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出：3 8 1 2 4 cout &lt;&lt; endl; sort(num, num + 5); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出： 1 2 3 4 8 cout &lt;&lt; endl; sort(num, num + 5, cmp); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; num[i] &lt;&lt; \" \";//输出： 8 4 3 2 1 cout &lt;&lt; endl; return 0; } 其他数据类型同理可知。 结构体数组的排序 结构体本身并无直接可比性，所以就没有默认排序一说，都需要通过书写cmp函数来实现人为制定比较规则。 一级排序： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; struct test { int x, y; }ss[5]; bool cmp(test a, test b) { return a.x &lt; b.x;//“&lt;”从小至大 “&gt;”从大至小 } int main() { for (int i = 0; i &lt; 5; i++) { ss[i].x = rand()%17; ss[i].y = rand()%17;//随机数 } for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; ss[i].x &lt;&lt; \" \" &lt;&lt; ss[i].y &lt;&lt; endl; } cout &lt;&lt; endl; sort(ss, ss + 5, cmp); for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; ss[i].x &lt;&lt; \" \" &lt;&lt; ss[i].y &lt;&lt; endl; } return 0; } 很明显可以发现，一级排序仅仅只会排序结构体中的第一个变量，若想实现第二个变量的排序，只需改变cmp函数的写法 bool cmp(test a, test b) { if (a.x != b.x)return a.x &lt; b.x; else return a.y &gt; b.y; }//x从小到大，y从大到小的顺序 类似的可以进行扩展。 STL容器的排序 前提：STL容器中只有vector、string、deque才可以使用sort函数进行排序 用法类似于数组，牢记“左闭右开”的规则。 lower_bound（）和upper_bound（）前提：数组或容器本身是有序的 lower_bound（left，right，num）用来在容器或数组的[left，right）中查找第一个大于或等于num的元素的位置。若为数组，返回指针；若为容器，返回迭代器。 相应的，upper_bound（）函数的作用是查找第一个大于num的元素的位置。 换言之，假设本身数组或容器内不存在该元素，两个函数均返回可以插入该元素的位置。（即若存在，应该在哪个位置） 小技巧：通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 重载前提：针对从大到小排序的数组或容器，利用重载来实现查找 大同小异： lower_bound(left,right,num,greater&lt;type&gt;()); //查找第一个小于或等于num的元素位置 upper_bound(left,right,num,greater&lt;type&gt;()); //查找第一个小于num的元素位置 示例如下： #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; bool cmp(int a, int b) { return a &gt; b; } int main() { int a[9]{}; for (int i = 0; i &lt; 9; i++) a[i] = rand() % 5 + 1; sort(a, a + 9); for (int i = 0; i &lt; 9; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; int pos1 = lower_bound(a, a + 9, 3) - a; cout &lt;&lt; pos1 &lt;&lt; \" \"; int pos2 = upper_bound(a, a + 9, 3) - a; cout &lt;&lt; pos2 &lt;&lt; endl; sort(a, a + 9, cmp); for (int i = 0; i &lt; 9; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; pos1 = lower_bound(a, a + 9, 3,greater&lt;int&gt;()) - a; cout &lt;&lt; pos1 &lt;&lt; \" \"; pos2 = upper_bound(a, a + 9, 3,greater&lt;int&gt;()) - a; cout &lt;&lt; pos2 &lt;&lt; endl; return 0; } 补充： partial_sumpartial_sum 是C++ STL 算法组件中的其中一个算法，其作用是计算某个序列局部元素的和。它有四个重载函数。要使用 partial_sum 需要引用头文件 numeric。 一般来说，使用partical_sum函数需要四个参数 partial_sum(容器要计算的起始位置，容器要计算的结束位置，结果存放的起始位置，自定义函数) 其中自定义函数可以留白，则默认计算局部和。而且，结果可以存放在原容器内。 示例如下： #include &lt;iostream&gt; #include &lt;numeric&gt; using namespace std; int cmp(int x, int y) { return x - y; } int main () { int test[10]; int ans[10]; for (int i = 0; i &lt; 10; i++) test[i] = rand() % 57; for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; partial_sum(test, test + 10, ans); for (int i = 0; i &lt; 10; i++) cout &lt;&lt; ans[i] &lt;&lt; \" \"; cout &lt;&lt; endl; partial_sum(test, test + 10, test, cmp); for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return 0; } 运行结果如下： 可以很直接看到用法，此函数通常可以用于前缀和，减少代码量。 max_element和min_element作用：返回最大值和最小值的地址 示例如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int main () { int test[10]; for (int i = 0; i &lt; 10; i++) test[i] = rand() % 57; for (int i = 0; i &lt; 10; i++) cout &lt;&lt; test[i] &lt;&lt; \" \"; cout &lt;&lt; endl; cout &lt;&lt; max_element(test, test + 10) &lt;&lt; endl;//输出地址 cout &lt;&lt; *max_element(test, test + 10) &lt;&lt; endl;//输出元素 cout &lt;&lt; max_element(test, test + 10) - test &lt;&lt; endl;//输出在数组中的位置 return 0; } 运行结果： END","categories":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"}],"author":"HeeKaai"},{"title":"STL入门---容器篇","slug":"STL入门-容器","date":"2022-01-30T13:15:10.000Z","updated":"2022-03-09T05:18:16.837Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://heekaai.github.io/posts/2.html","excerpt":"","text":"[TOC] 写在前面此文介绍STL中的容器部分，仅仅涉及入门知识及一些常见的用法。 vector vector 在英文中翻译为向量，但是在C++中把它叫做“变长数组”，更加容易理解它的用法。顾名思义：vector容器是长度根据需要而自动改变的数组。 如果要使用vector容器，需要在头文件里加上#include&lt; vector &gt; vector的定义讲vector的定义之前，可以先回顾一下数组的定义方法。 typename arrayname[arraysize]; //一维数组 typename arrayname[arraysize1][arraysize2]; //二维数组 下面再来看vector的定义： vector&lt;typename&gt; name; 和一维数组一样，typename可以是所有的基本类型，例如：int、double、char、结构体······当然也可以是STL中的其他容器，例如：vector、set、queue······ vector数组的定义 vector&lt;typename&gt; name[size]; 例如： vector&lt;int&gt; ve[100]; 这样ve[0]到ve[99]每一维都是一个vector容器。 当然，如果我们把typename也改成vector容器，同样可以实现二维数组的功能。 vector&lt;vector&lt;int&gt;&gt; name; 这样数组的两个维度都是“变长”的。而vector\\ name[size]其中一维的长度就已经固定了。稍微体会一下这两者的区别。 访问vector容器中的元素vector容器有两种访问方式：通过下标或者迭代器访问。下面分别讲到这两种访问方式。 通过下标访问 和访问普通的数组一样，对于一个定义为vector&lt;int&gt;ve的vector容器而言，直接访问ve[index]即可。当然这个下标访问和普通数组一样是从0~~ve.size（）-1，也需要注意存在越界的问题。 通过迭代器访问 迭代器（iterator）可以理解为一个类似于指针的东西，其定义为： vector&lt;typename&gt;::iterator it; 这样定义之后 i t 就是vector\\::iterator 型的变量。也即迭代器 i t ，并且可以通过*i t来访问vector中的元素。 比如说： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=0;i&lt;6;i++) ve.push_back(i); //后面会提，在ve的末尾添加元素i for(int i=0;i&lt;6;i++) cout&lt;&lt;ve[i]&lt;&lt;\" \"; cout&lt;&lt;endl; vector&lt;int&gt;::iterator it=ve.begin(); //it指向ve的首地址 for(int i=0;i&lt;6;i++) cout&lt;&lt;*(it+i)&lt;&lt;\" \"; cout&lt;&lt;endl; return 0; } 从上面给出的例程，可以看出ve[i]和*(it+i)是等价的。 上面的代码中出现了ve.begin（），其作用是取到vector容器的首地址。而ve.end（）却不是取到vector容器的末尾地址，而是末尾元素的下一个地址。 另外，需要注意的还有迭代器还支持自加和自减操作，则遍历vector容器还有第三种写法： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=0;i&lt;6;i++) ve.push_back(i); vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; cout&lt;&lt;endl; return 0; } vector容器的常用函数 push_back（） 上面的代码就已经使用过这种方式添加过元素了。很简单，和函数名一样，push_back(x) 的作用就是在 vector 容器最后添加上元素 x ，时间复杂度是 O（1） 。 pop_back（） 有添加作用的函数自然，相对的肯定会有删减作用的函数。pop_back（） 用以删除vector容器中的最后一个元素，时间复杂度同样为 O（1）。 比如说： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it; cout&lt;&lt;\" \"; } putchar('\\n'); ve.pop_back(); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it; cout&lt;&lt;\" \"; } putchar('\\n'); return 0; } size（） size（）函数用以获取vector容器中的元素个数。 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } cout&lt;&lt;ve.size()&lt;&lt;endl; return 0; } clear（） clear（）用以清空vector容器中的所有元素，时间复杂度是 O（N) ，其中N是vector容器中的元素个数。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } cout&lt;&lt;ve.size()&lt;&lt;endl; //输出5 ve.clear(); cout&lt;&lt;ve.size()&lt;&lt;endl; //输出0 return 0; } insert（） insert（it,x）用以向vector容器的任意迭代器it位置插入一个元素x，时间复杂度为 O（N)。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; it=ve.begin()+2; //*** ve.insert(it,-1); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 -1 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } 需要特别说明的是，代码中注释标注为三个的地方，在常用的STL容器中，*只有在string和vector中，才允许使用ve.begin（）+2这种迭代器直接加上整数的写法！ erase（） erase（）也是一种删除函数，它有两种使用方法：删除单个元素以及删除一个区间内的所有元素。时间复杂度自然也是 O（N)。 （1）删除单个元素： erase（it）即删去迭代器 it 处的元素。 例如： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; it=ve.begin()+2; ve.erase(it); for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } （2）删除一个区间内的所有元素 遵循着“左闭右开”的原则，erase（left,right）即删去[first,right)内vector容器中的所有元素。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main () { vector&lt;int&gt; ve; for(int i=1;i&lt;=5;i++) { ve.push_back(i); } vector&lt;int&gt;::iterator it; for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 4 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; ve.erase(ve.begin()+1,ve.begin()+4); //删去下标为[1,4)的元素 for(it=ve.begin();it!=ve.end();it++) { cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 5 } cout&lt;&lt;endl&lt;&lt;ve.size()&lt;&lt;endl; return 0; } 所以清空vector容器除了上面提到的clear()函数外，现在也可以使用第二种方法：ve.erase（ve.begin（）,ve.end（））。这样只是加深对“左闭右开”的理解，因为ve.end（）指向的是末尾元素的下一个位置。当然clear（）函数明显更加方便、简洁。 string在C语言中，通常使用字符数组char s[] 来对字符串进行存储，在此基础上为了对字符串的操作更加的快捷、方便，C++在STL中加入了string类型，对字符串的常用功能进行了封装。如果要使用string，需要添加头文件\\（注意string.h和string是完全不一样的头文件）。下面来看看string容器的常用使用方法吧。 string的定义定义 string 的方式和其他的基本数据类型一致，只需要在 string 后面加上变量的名称即可。如果要进行初始化，定义时直接进行赋值即可。 string str; //定义 string str=\"abcd\"; //赋值 访问string容器中的元素（1）通过下标访问： 一般而言，可以像访问字符数组那样通过下标对string容器进行访问。 （2）通过迭代器访问： 定义迭代器： string::iterator it; //string类型无其他参数 关于使用迭代器对string容器中的元素进行访问的方法，类似于上文中的vector容器，在这里就不做过多阐述，可以参照上文。 如果要读入和输出整个字符串，则只能使用cin和cout。 最后需要注意的一点，string和vector一样，支持直接对迭代器进行加减某个数字，比如说str.begin（）+2 的写法是合法的。而对于STL的其他容器，则不支持这种写法。 string容器的常用函数（1）比较与拼接 因为 string 在C++中是一种数据类型，则可以像其他的变量一样进行加法运算及比较运算（比较的是字典序）。比如说： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abc\",str2=\"123\"; string str; str=str1+str2; cout&lt;&lt;str&lt;&lt;endl; //输出abc123 string str3=\"aaabc\",str4=\"aabc\"; cout&lt;&lt;(str3&gt;str4)&lt;&lt;endl; //返回0，str3字典序大于str4 return 0; } （2）length（）和 size（）函数 这两个函数都是返回 string 的长度，作用和运行效率基本相同。 （3）insert（）函数 string的insert（）函数，常见的写法有两种。 ①insert（pos，string），pos为string容器中的位置，string为待插入的字符串。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abcde\",str2=\"123\"; str1.insert(3,str2); //在str[3]处插入了“123” cout&lt;&lt;str1&lt;&lt;endl; //输出abc123de } ②insert（it，it2，it3）使用三个迭代器的写法，it 指向原字符串待插入的位置，it1、it2指向待插字符串的首尾元素，来表示串 [ it1,it2 )插入到 it 位置。（左闭右开原则） #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str1=\"abcde\",str2=\"123\"; str1.insert(str1.begin()+3,str2.begin(),str2.end()); cout&lt;&lt;str1&lt;&lt;endl; //abc123de } （4）erase（）函数 （5）clear（）函数 这两个函数用法和vector容器的用法一致，可以参照上文。 （6）substr（）函数 substr（pos，len）返回从pos号位置开始，长度为len的子串。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a nice day\"; cout&lt;&lt;str.substr(0,5)&lt;&lt;endl; //输出Today cout&lt;&lt;str.substr(11,4)&lt;&lt;endl; //输出nice } （7）find（）函数 str.find（str1)，即在str中找是否存在子串str1，若存在则返回子串首次出现的位置，否则返回string::npos常数（最大的unsigned_int，也相当于-1。） str.find（str1，pos)即将开始查找的位置定为pos，返回值和上面相同。 时间复杂度为 O（mn） 故使用需谨慎考虑时间复杂度。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a nice day\"; cout&lt;&lt;str.find(\"nice day\")&lt;&lt;endl; //返回11 cout&lt;&lt;str.find(\"bad day\")&lt;&lt;endl; if(str.find(\"bad day\")==-1)cout&lt;&lt;\"-1\"&lt;&lt;endl; } （10）replace（）函数 str.replace（pos，len，str1）把str的pos号位置开始，长度为len的子串替换为str1。 str.replace（it1，it2，str1）把str [ it1，it2 ) 替换为str1。 示例如下： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; int main () { string str=\"Today is a bad day\"; cout&lt;&lt;str&lt;&lt;endl; string str1=\"nice\",str2=\"Tomorrow\"; str.replace(11,3,str1); cout&lt;&lt;str&lt;&lt;endl; //输出 Today is a nice day str.replace(str.begin(),str.begin()+5,str2); cout&lt;&lt;str&lt;&lt;endl; //输出 Tomorrow is a nice day } setset在英文中翻译为集合，是一个内部自动有序且不含重复元素的容器。如果要使用set容器，则需要在头文件中添加&lt; set &gt;。 set的定义set的定义的写法其实和vector基本上是一样的，或者说大部分STL容器都是这样定义的。 #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;typename&gt; name; //一维 set&lt;typename&gt; arrayname[arraysize]; //二维 } set容器内元素的访问set 容器内的元素只能通过迭代器进行访问。且 set 容器不支持*（it+i）的访问方式，因此常用的枚举方式如下： #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; //定义set容器 st.insert(2); //用insert插入元素 st.insert(1); st.insert(3); st.insert(2); set&lt;int&gt;::iterator it; //定义迭代器 for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 3 cout&lt;&lt;endl; } 从输出结果可以发现，set容器内部自动实现了递增排序且删除了重复的元素。 set容器常用函数 insert（） insert（x）可将x插入容器中，且实现自动升序和去重，时间复杂度是O（logN）其中 N 是当前容器中的元素个数。 find（） find（x）返回set容器中对应值为x的迭代器（而不是下标 string返回的是对应下标），时间复杂度是O（logN）其中 N 是当前容器中的元素个数。 earse（） 同样，erase函数有两种用法：单个元素和区间元素删除。 （1）删除单个元素： erase（it）即删去迭代器 it 处的元素。可结合find（）函数进行使用。 示例如下： #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; for(int i=1;i&lt;5;i++) st.insert(i); set&lt;int&gt;::iterator it; it=st.find(3); st.erase(it); for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 cout&lt;&lt;endl; } erase（value），value为待删除元素的值。时间复杂度为O（N) #include&lt;iostream&gt; #include&lt;set&gt; //记得添加头文件 using namespace std; int main () { set&lt;int&gt; st; for(int i=1;i&lt;5;i++) st.insert(i); set&lt;int&gt;::iterator it; st.erase(3); for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;\" \"; //输出1 2 4 cout&lt;&lt;endl; } （2）删除一个区间内的所有元素 用法和上文提到的vector容器的用法一致，可以参照上文。 size（） clear（） 用法同样是类似的，在这里就不做过多的阐述了。 mapmap在英文中翻译为映射，也是常用的STL容器。 一个简单的引入：在定义数组时（比如说int array[ 100 ]),其实就可以理解为一个int -&gt; int 的映射。而map容器则可以将任何数据类型映射到任何数据类型（当然也包括STL容器）。 map容器的定义单独定义一个map： map&lt;typename1,typename2&gt; mp; 我们把映射前类型称为键（key），映射后类型称为值（value）。 特别说明：当字符串作为键值时，不能使用char[ ]型的数组，而应该是使用string容器。并且，map中的键是唯一的，和数学中的映射概念是一致的。 map容器内元素的访问map容器一般有两种访问方式：通过下标访问或通过迭代器访问。下面来讨论这两种访问方式。 （1）通过下标访问 和引入部分提到的，就和访问普通的数组是一样的，可以通过下标进行赋值和访问。 #include&lt;iostream&gt; #include&lt;map&gt; //记得添加头文件 using namespace std; int main () { map&lt;char,int&gt;mp; char ch='a'; for(int i=1;i&lt;=26;i++) { mp[ch]=i; //赋值 ch++; } cout&lt;&lt;mp['h']&lt;&lt;\" \"&lt;&lt;mp['k']&lt;&lt;endl; //输出8 11 return 0; } （2）通过迭代器访问 map容器的迭代器定义方式和其他STL容器迭代器定义方式相同。 但是因为在定义时有两个数据类型，所以在使用map容器的迭代器时，可以使用 it -&gt; first 来访问键，使用 it -&gt; second 来访问值。 例如： #include&lt;iostream&gt; #include&lt;map&gt; using namespace std; int main () { map&lt;char,int&gt;mp; char ch='a'; for(int i=1;i&lt;=5;i++) { mp[ch]=i; ch++; } map&lt;char,int&gt;::iterator it; for(it=mp.begin();it!=mp.end();it++) { cout&lt;&lt;it -&gt; first&lt;&lt;\" \"&lt;&lt;it -&gt; second&lt;&lt;endl;//输出a-e 1-5 } return 0; } 虽然上面代码赋值是从小到大，但是实际上map容器的键值会以从小到大的顺序自动排序（类似于 set容器内部使用红黑树来实现）。 map容器常用函数 find（）函数 find（key）返回键值为key的映射的迭代器，时间复杂度为O（logN） erase（）函数 mp.erase（x）其中x可以为键值或者迭代器 区间删除类似于set容器，可以参照上文的set容器。 size（）函数 得到的是映射的对数 clear（）函数 用法同样类似，在此不做赘述。 stack stack的英文翻译是栈，是STL中实现后进先出的容器。 stack定义stack定义方法和上面提到的容器类似，typename可以是任意的数据类型。使用stack容器时，头文件一定不要忘记添加#include&lt; stack &gt; stack容器内元素的访问由于stack容器后进先出的特性，故只能通过top（）来访问栈顶元素 简单例子： #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main () { stack&lt;int&gt; st; for(int i=0;i&lt;5;i++) st.push(i); cout&lt;&lt;st.top()&lt;&lt;endl; //输出 4 } 从上面这个例子不难看出stack容器后进先出的特性以及top（）函数的用法。 stack容器常用函数的使用 push（） push（x）将元素x入栈，时间复杂度为 O（1） top（） 获取栈顶元素 pop（） 弹出栈顶元素 empty（） 用以检查栈内元素是否为空，若为空即返回true，否则返回false。 size（） 返回容器内的元素个数 queue queue的英文翻译是队列，是STL中实现先进先出功能的容器。 queue容器的定义首先还是要提醒使用时记得添加头文件#includ&lt; queue &gt;，其余写法和其他的STL容器类似。 queue容器内的元素访问参照栈，由于队列具有先进先出的特性，所以queue容器只允许通过front（）和back（）来访问队列中对首元素和队尾元素。 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { queue&lt;int&gt;q; for(int i=0;i&lt;5;i++) q.push(i); cout&lt;&lt;q.front()&lt;&lt;\" \"&lt;&lt;q.back(); //输出： 1 5 return 0; } queue常用函数 push（） front（）、back（） 以上函数在上面示例可以看到简单用法 pop（） pop（）函数令队首元素出队，时间复杂度是O（1） empty（） 检查queue容器内是否为空，若为空返回true，否则返回false size（） 返回queue容器内的元素个数。 priority_queuepriority_queue又称为优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是优先级别最高的元素。当然这里的优先级则是规定出来的。 priority_queue容器的定义定义方式和queue容器的定义方式相同 priority_queue容器内元素的访问和queue容器不同的是，priority_queue容器并没有front（）函数和back（）函数，只能通过top（）函数来访问其堆顶元素（即优先级别最高的元素） 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { priority_queue&lt;int&gt;pq; for(int i=0;i&lt;5;i++) pq.push(i*2); for(;;) { if(pq.empty())break; cout&lt;&lt;pq.top()&lt;&lt;\" \"; pq.pop(); } cout&lt;&lt;endl; //输出： 8 6 4 2 0 return 0; } 可以发现，在未涉及优先级时，用法是和queue容器大同小异的。 priority_queue容器的常用函数 push（） top（） pop（） empty（） size（） 以上函数都可以在上面的示例当中看到简单应用。 priority_queue内元素的优先级的设置如何定义优先队列中的元素优先级是运用好优先队列的关键，下面来介绍设计首先队列元素的优先级别的方法。 基本数据类型的优先级设置这里提及的基本数据类型包括：int、char、double，优先队列对其默认是数字越大的优先级别越高（char型则比较的是字典序），则默认写法的详细写法为： priority_queue&lt;int&gt; name; priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; name; //以上两种写法是完全等价的 若使用char或double则将int全部改为char或double即可。 若想设置数字越小优先级别越高，将less&lt; int &gt;替换为greater&lt; int &gt;即可 #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main () { priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;pq; for(int i=0;i&lt;5;i++) pq.push(i*2); for(;;) { if(pq.empty())break; cout&lt;&lt;pq.top()&lt;&lt;\" \"; pq.pop(); } cout&lt;&lt;endl; //输出0 2 4 6 8 return 0; } 结构体的优先级的设置引入一个小小的例子，对商品的名称及价格建立一个结构体，并且规定价格高的商品优先级别更高。 struct goods{ string name; int price; }; //定义结构体 为实现优先级的规定，必须在结构体中添加比较功能。 struct goods{ string name; int price; friend bool operator &lt; (goods g1, goods g2){ return g1.price &lt; g2.price } //重载小于号“&lt;” }; 示例如下： #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;string&gt; using namespace std; struct goods { int price; string name; friend bool operator &lt; (goods g1, goods g2) { return g1.price&lt;g2.price; } }; int main () { goods g1,g2,g3; priority_queue&lt;goods&gt; q; g1.name=\"milk\";g1.price=10; g2.name=\"apple\";g2.price=8; g3.name=\"meet\";g3.price=12; q.push(g1); q.push(g2); q.push(g3); for(;;) { if(q.empty())break; cout&lt;&lt;q.top().name&lt;&lt;\" \"&lt;&lt;q.top().price&lt;&lt;endl; q.pop(); } return 0; } //输出： meet 12 milk 10 apple 8 这里的重载符号的作用其实和sort函数中的cmp函数相似，但是实现的效果两者是相反的（在排序中return的是“&gt;”那么就是从大到小排序），这一点需要特别注意。 pair同样顾名思义，pair的英文翻译是：一对、一双，也即把两个元素绑在一起当作一个合成元素。可以理解为一个内部有两个元素的结构体。 pair的定义要使用pair容器首先必须添加头文件#include&lt; utility &gt;，需要注意的是，由于map容器的内部涉及到了pair，所以如果头文件中添加了#include&lt; map &gt;就可以直接使用pair容器。 对比结构体和pair： struct pair{ typename1 first; typename2 second; } pair&lt;typename1,typename2&gt; name; pair容器内元素的访问pair容器内只存在两个元素，访问方式和结构体访问方式类似。 示例如下： #include&lt;utility&gt; #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; int main () { pair&lt;string,int&gt;p(\"abc\",123); cout&lt;&lt;p.first&lt;&lt;\" \"&lt;&lt;p.second&lt;&lt;endl; return 0; } 常见用法有： 比较操作数 两个pair类型数据可以直接使用==、！=、&lt;等比较大小，比较规则是先比较first，在first相同的情况下才去比较second的大小。 作为map的键值进行插入 listlist容器的定义list是双向循环列表，每一个元素都知道前一个元素和后一个元素，所以和vector相比，list能够更快的插入和删除，但是随机访问却比较慢。 定义与初始化： list&lt;typename&gt; lis1;//创建空的list list&lt;typename&gt; lis1(n);//创建含有n个元素的list list&lt;typename&gt; lis1(n,val);//创建n含有n各元素且值为val的list list&lt;typename&gt; lis1(lis2);//用lis2初始化lis1 list的访问与常用函数 assign（）函数用于赋值 begin（），end（）返回首尾元素的迭代器 front（），back（）返回首尾元素 size（）返回容器的元素个数 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis1; list&lt;int&gt;lis2(4, 10); int num[6] = {2, 17, 4, 55, 78, 16}; lis1.assign(lis2.begin(), lis2.end()); list&lt;int&gt;::iterator it; for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; //输出：10 10 10 10 cout &lt;&lt; endl; lis1.assign(num, num + 6); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \";//输出：2,17,4,55,78,16 cout &lt;&lt; endl; return 0; } 5.erase（）动态删除，返回当前迭代器的下一个节点（返回迭代器）。区间删除，单个删除均可以实现。 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis; for (int i = 1; i &lt;= 8; i++) lis.push_back(i); list&lt;int&gt;::iterator it, it1, it2; for (it = lis.begin(); it != lis.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \" ;//输出： 1 2 3 4 5 6 7 8 cout &lt;&lt; endl; it1 = it2 = lis.begin(); advance(it2, 6); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl; //输出 1 7 it1 = lis.erase(it1); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl; //输出 2 7 it2 = lis.erase(it2); cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl;// 输出 2 8 it1++; it2--; lis.erase(it1, it2);//输出2 6 8 for (it = lis.begin(); it != lis.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \" ; cout &lt;&lt; endl; return 0; } 6.insert（）插入元素 单个元素以及区间插入均可实现 特别注意：返回的迭代器是原来的位置，插入的坐标迭代器指向的元素不变。 #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis; for (int i = 1; i &lt;= 6; i++) lis.push_back(i); list&lt;int&gt;::iterator it = lis.begin(), it1; it1 = lis.insert(it, 10); cout &lt;&lt; *it &lt;&lt; endl &lt;&lt; *it1 &lt;&lt; endl;//it指向1 it1指向10 return 0; } 7.splice（）把链表中的元素从一个移到另一个链表中（可以理解为剪切函数）函数无返回值 常见有三种用法，代码如下： #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main() { list&lt;int&gt;lis1{1, 2, 3, 4, 5}; list&lt;int&gt;lis2{11, 22, 33, 44, 55}; //用法一 auto it = lis1.begin(); advance(it, 3); lis1.splice(it, lis2); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; if (lis2.empty()) cout &lt;&lt; \"lis2 is empty\" &lt;&lt; endl; /* 注意两点： 1.插入的位置（在迭代器指向的位置之前插入lis2） 2.lis中的元素被转移后容器清空了 时间复杂度常数级别 */ //用法二 cout &lt;&lt; endl &lt;&lt; endl; it = lis1.begin(); lis2.splice(lis2.begin(), lis1, it); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; for (it = lis2.begin(); it != lis2.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; /* 同样注意用法一的那两点 时间复杂度常数级别 */ //用法三 cout &lt;&lt; endl &lt;&lt; endl; it = lis1.begin(); advance(it, 3); // it-&gt;22 lis2.splice(lis2.end(), lis1, it, lis1.end()); for (it = lis1.begin(); it != lis1.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; for (it = lis2.begin(); it != lis2.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; /* 注意： 1.区间插入 左闭右开 2.删除原有元素 3.插入的位置 时间复杂度线性级别 */ return 0; } 8.merge（）合并两个有序的list，合并后仍然有序。（默认是递增的） 9.reverse（)倒转list END","categories":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"}],"author":"HeeKaai"},{"title":"C语言期末复习笔记","slug":"C语言期末复习笔记","date":"2022-01-06T15:24:12.000Z","updated":"2022-01-10T06:24:58.032Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://heekaai.github.io/posts/1.html","excerpt":"","text":"[TOC] 前言​ 临近期末考试（C语言程序设计），本人也是从暑假（7月份）开始接触的C语言，可以说是一只纯正的小白，为了更好、更有效率的备考，这篇博客也就由此诞生了。 ​ 顺序没啥讲究，完全是想到了什么就写出来了。很多算法优化空间还有很大。 动态规划初步​ 动态规划其实我感觉也可以叫作记忆化的递归优化，顾名思义，就是一种把递归可能会产生的重复运算记录下来，以空间换时间（当然空间复杂度的代价也是可以降到最小的，比如说滚动数组来实现）。 DP的组成部分​ 几乎每一道可以用动态规划来解决的题目，设计算法的时候都可以被拆解为以下的几步： 确定状态（定海神针的作用） 最后一步 子问题 （由最后一步将问题分解，即解决子问题+最后一步） 确定状态转移方程 子问题定下来，状态转移就是子问题的一般化过程 初始化与边界 计算顺序 这四步听起来好像不太好理解，但是动态规划的核心就在这。通过题目应该可以更好的思考和理解动态规划的组成部分。 例题坐标型DP题目描述： &gt;&gt; 如图，A 点有一个过河卒，需要走到目标 B 点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如上图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图 C 点上的马可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。 棋盘用坐标表示，A 点（0,0）、B 点（n,m）(n,m 为不超过 20 的整数，并由键盘输入)，同样马的位置坐标是需要给出的（约定: C&lt;&gt;A，同时C&lt;&gt;B）。现在要求你计算出卒从 A 点能够到达 B 点的路径的条数。 输入描述： 输入B点的坐标（n,m）以及对方马的坐标（X,Y） (不用判错) 输出描述： 输出一个整数表示路径的条数。 样例输入： 6 6 3 2 样例输出： 17 原题链接：Nowcoder-过河卒 题目分析： 参照上面的DP组成部分，一步一步来： 最后一步：最后一定会到达（n，m）的位置 子问题：在没有马控制的前提下，一定是由（n-1，m）或者（n，m-1）过来 状态转移方程：dp[i] [j]=dp[i-1] [j]+dp[i] [j-1] 初始化与边界：首先马的领地是不能到的，直接记为0；然后就是第一行和第一列都是1；在初始化第一行第一列的时候，遇到马就直接break，因为后面的都到不了了； AC代码： #include&lt;stdio.h&gt; #include&lt;stdbool.h&gt; #include&lt;string.h&gt; long long dp[25][25]; bool judge[25][25];//判断是否为马的领地，布尔数组合适 int main () { memset(judge,true,sizeof(judge)); int n,m,x,y; scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;x,&amp;y); judge[x][y]=0; judge[x-2][y-1]=judge[x-2][y+1]=judge[x-1][y-2]=judge[x-1][y+2]=0; judge[x+2][y-1]=judge[x+2][y+1]=judge[x+1][y-2]=judge[x+1][y+2]=0; for(int i=0;i&lt;=m;i++) { if(judge[0][i])dp[0][i]=1; else break; } for(int j=0;j&lt;=n;j++) { if(judge[j][0])dp[j][0]=1; else break; } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(judge[i][j])dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } printf(\"%lld\\n\",dp[n][m]); } 序列DP原题链接：XTUOJBlocks 题目描述： 给你一个n块积木，每个积木块都是立方体，现在把它们排列一排，成m列，要求每列上至少有1个积木，且从左到右，每列的积木数量呈严格单调下降。 ​ 题意即求n等于m个不同的数相加的方案数 最后一步：m个数不同，则一定有最大的数，记为k。 子问题：则求解n-k等于m-1个不同的数相加的方案数。 状态转移方程： dp(i,j,k)=\\sum_{t","categories":[{"name":"C语言","slug":"C语言","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"算法笔记","slug":"C语言/算法笔记","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"C语言/算法笔记/基础","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"C","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"学习","slug":"学习","permalink":"https://heekaai.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"基础算法","slug":"基础算法","permalink":"https://heekaai.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"author":"HeeKaai"},{"title":"博客的诞生","slug":"博客的诞生","date":"2022-01-03T14:35:02.000Z","updated":"2022-01-19T02:20:57.023Z","comments":true,"path":"posts/3c47c717.html","link":"","permalink":"https://heekaai.github.io/posts/3c47c717.html","excerpt":"","text":"相遇就是缘！ 为什么要搭建博客？纯属自己的个人兴趣吧！记录自己最近都干了什么，学到了什么，或许会有一些成就感吧！拥有一个自己的博客写一写自己感兴趣或者正在研究的事或物，不是一件很有意义的事情嘛！ 展望博客我会整理一些自己目前在学的东西，一方面能够让自己复习，一方面也能记录一下学习的过程，也希望能够让有兴趣的小伙伴能够看到，也是一个共同进步的过程。 关于博主我真的是一个很懒很懒的人，平时最喜欢干的事情就是睡觉。希望通过写博客来提高提高自己的学习积极性。 “人间失格”听上去真的很非主流，我自己也这么觉得。但是取名字我觉得更加麻烦，《人间失格》是太宰治的一本书，索性就直接引用过来了。 最后拿《人间失格》里的一句话作结吧 如今的我，谈不上幸福，也谈不上不幸。 一切都会过去的。 在所谓的“人世间”摸爬滚打至今， 我唯一愿意视为真理的，就只有这一句话， 一切都会过去的！ ​ ————太宰治《人间失格》 感谢你看到了最后！","categories":[{"name":"简介","slug":"简介","permalink":"https://heekaai.github.io/categories/%E7%AE%80%E4%BB%8B/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://heekaai.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"HeeKaai"},{"title":"Hello World","slug":"hello-world","date":"2022-01-02T12:28:30.418Z","updated":"2022-01-02T15:36:49.102Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://heekaai.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"动态连通性问题","slug":"算法/数据结构/动态连通性问题","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/"},{"name":"基础","slug":"算法/基础","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/"},{"name":"CRT模板","slug":"算法/基础/CRT模板","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/"},{"name":"扩展欧几里得","slug":"算法/基础/CRT模板/扩展欧几里得","permalink":"https://heekaai.github.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/CRT%E6%A8%A1%E6%9D%BF/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"STL","slug":"C/基础/STL","permalink":"https://heekaai.github.io/categories/C/%E5%9F%BA%E7%A1%80/STL/"},{"name":"C语言","slug":"C语言","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"算法笔记","slug":"C语言/算法笔记","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"C语言/算法笔记/基础","permalink":"https://heekaai.github.io/categories/C%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80/"},{"name":"简介","slug":"简介","permalink":"https://heekaai.github.io/categories/%E7%AE%80%E4%BB%8B/"}],"tags":[{"name":"大一","slug":"大一","permalink":"https://heekaai.github.io/tags/%E5%A4%A7%E4%B8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://heekaai.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"https://heekaai.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"C++","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://heekaai.github.io/tags/STL/"},{"name":"假期","slug":"假期","permalink":"https://heekaai.github.io/tags/%E5%81%87%E6%9C%9F/"},{"name":"C","slug":"C","permalink":"https://heekaai.github.io/tags/C/"},{"name":"学习","slug":"学习","permalink":"https://heekaai.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"基础算法","slug":"基础算法","permalink":"https://heekaai.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"生活","slug":"生活","permalink":"https://heekaai.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}